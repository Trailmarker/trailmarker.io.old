{"version":3,"sources":["clojure/test/check/generators.cljc"],"sourcesContent":[";   Copyright (c) Rich Hickey, Reid Draper, and contributors.\n;   All rights reserved.\n;   The use and distribution terms for this software are covered by the\n;   Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)\n;   which can be found in the file epl-v10.html at the root of this distribution.\n;   By using this software in any fashion, you are agreeing to be bound by\n;   the terms of this license.\n;   You must not remove this notice, or any other, from this software.\n\n(ns clojure.test.check.generators\n  (:refer-clojure :exclude [int vector list hash-map map keyword\n                            char boolean byte bytes sequence\n                            shuffle not-empty symbol namespace\n                            set sorted-set uuid double let])\n  (:require [#?(:clj clojure.core :cljs cljs.core) :as core\n             #?@(:cljs [:include-macros true])]\n            [clojure.test.check.random :as random]\n            [clojure.test.check.rose-tree :as rose]\n            #?@(:cljs [[goog.string :as gstring]\n                       [clojure.string]])))\n\n\n;; Gen\n;; (internal functions)\n;; ---------------------------------------------------------------------------\n\n(defrecord Generator [gen])\n\n(defn generator?\n  \"Test if `x` is a generator. Generators should be treated as opaque values.\"\n  [x]\n  (instance? Generator x))\n\n(defn- make-gen\n  [generator-fn]\n  (Generator. generator-fn))\n\n(defn call-gen\n  {:no-doc true}\n  [{generator-fn :gen} rnd size]\n  (generator-fn rnd size))\n\n(defn gen-pure\n  {:no-doc true}\n  [value]\n  (make-gen\n    (fn [rnd size]\n      value)))\n\n(defn gen-fmap\n  {:no-doc true}\n  [k {h :gen}]\n  (make-gen\n    (fn [rnd size]\n      (k (h rnd size)))))\n\n(defn gen-bind\n  {:no-doc true}\n  [{h :gen} k]\n  (make-gen\n    (fn [rnd size]\n      (core/let [[r1 r2] (random/split rnd)\n            inner (h r1 size)\n            {result :gen} (k inner)]\n        (result r2 size)))))\n\n(defn lazy-random-states\n  \"Given a random number generator, returns an infinite lazy sequence\n  of random number generators.\"\n  [rr]\n  (lazy-seq\n   (core/let [[r1 r2] (random/split rr)]\n     (cons r1\n           (lazy-random-states r2)))))\n\n(defn- gen-seq->seq-gen\n  \"Takes a sequence of generators and returns a generator of sequences (er, vectors).\"\n  [gens]\n  (make-gen\n   (fn [rnd size]\n     (mapv #(call-gen % %2 size) gens (random/split-n rnd (count gens))))))\n\n;; Exported generator functions\n;; ---------------------------------------------------------------------------\n\n(defn fmap\n  [f gen]\n  (assert (generator? gen) \"Second arg to fmap must be a generator\")\n  (gen-fmap #(rose/fmap f %) gen))\n\n\n(defn return\n  \"Create a generator that always returns `value`,\n  and never shrinks. You can think of this as\n  the `constantly` of generators.\"\n  [value]\n  (gen-pure (rose/pure value)))\n\n(defn- bind-helper\n  [k]\n  (fn [rose]\n    (gen-fmap rose/join\n              (make-gen\n                (fn [rnd size]\n                  (rose/fmap #(call-gen % rnd size)\n                             (rose/fmap k rose)))))))\n\n(defn bind\n  \"Create a new generator that passes the result of `gen` into function\n  `k`. `k` should return a new generator. This allows you to create new\n  generators that depend on the value of other generators. For example,\n  to create a generator which first generates a vector of integers, and\n  then chooses a random element from that vector:\n\n      (gen/bind (gen/such-that not-empty (gen/vector gen/int))\n                ;; this function takes a realized vector,\n                ;; and then returns a new generator which\n                ;; chooses a random element from it\n                gen/elements)\n\n  \"\n  [generator k]\n  (assert (generator? generator) \"First arg to bind must be a generator\")\n  (gen-bind generator (bind-helper k)))\n\n;; Helpers\n;; ---------------------------------------------------------------------------\n\n(defn make-size-range-seq\n  {:no-doc true}\n  [max-size]\n  (cycle (range 0 max-size)))\n\n(defn sample-seq\n  \"Return a sequence of realized values from `generator`.\"\n  ([generator] (sample-seq generator 100))\n  ([generator max-size]\n   (core/let [r (random/make-random)\n         size-seq (make-size-range-seq max-size)]\n     (core/map #(rose/root (call-gen generator %1 %2))\n               (lazy-random-states r)\n               size-seq))))\n\n(defn sample\n  \"Return a sequence of `num-samples` (default 10)\n  realized values from `generator`.\"\n  ([generator]\n   (sample generator 10))\n  ([generator num-samples]\n   (assert (generator? generator) \"First arg to sample must be a generator\")\n   (take num-samples (sample-seq generator))))\n\n\n(defn generate\n  \"Returns a single sample value from the generator, using a default\n  size of 30.\"\n  ([generator]\n     (generate generator 30))\n  ([generator size]\n     (core/let [rng (random/make-random)]\n       (rose/root (call-gen generator rng size)))))\n\n\n;; Internal Helpers\n;; ---------------------------------------------------------------------------\n\n(defn- halfs\n  [n]\n  (take-while #(not= 0 %) (iterate #(quot % 2) n)))\n\n(defn- shrink-int\n  [integer]\n  (core/map #(- integer %) (halfs integer)))\n\n(defn- int-rose-tree\n  [value]\n  (rose/make-rose value (core/map int-rose-tree (shrink-int value))))\n\n;; calc-long is factored out to support testing the surprisingly tricky double math.  Note:\n;; An extreme long value does not have a precision-preserving representation as a double.\n;; Be careful about changing this code unless you understand what's happening in these\n;; examples:\n;;\n;; (= (long (- Integer/MAX_VALUE (double (- Integer/MAX_VALUE 10)))) 10)\n;; (= (long (- Long/MAX_VALUE (double (- Long/MAX_VALUE 10)))) 0)\n\n(defn- calc-long\n  [factor lower upper]\n  ;; these pre- and post-conditions are disabled for deployment\n  #_ {:pre [(float? factor) (>= factor 0.0) (< factor 1.0)\n            (integer? lower) (integer? upper) (<= lower upper)]\n      :post [(integer? %)]}\n  ;; Use -' on width to maintain accuracy with overflow protection.\n  #?(:clj\n     (core/let [width (-' upper lower -1)]\n       ;; Preserve long precision if the width is in the long range.  Otherwise, we must accept\n       ;; less precision because doubles don't have enough bits to preserve long equivalence at\n       ;; extreme values.\n       (if (< width Long/MAX_VALUE)\n         (+ lower (long (Math/floor (* factor width))))\n         ;; Clamp down to upper because double math.\n         (min upper (long (Math/floor (+ lower (* factor width)))))))\n\n     :cljs\n     (long (Math/floor (+ lower (- (* factor (+ 1.0 upper))\n                                    (* factor lower)))))))\n\n(defn- rand-range\n  [rnd lower upper]\n  {:pre [(<= lower upper)]}\n  (calc-long (random/rand-double rnd) lower upper))\n\n(defn sized\n  \"Create a generator that depends on the size parameter.\n  `sized-gen` is a function that takes an integer and returns\n  a generator.\"\n  [sized-gen]\n  (make-gen\n    (fn [rnd size]\n      (core/let [sized-gen (sized-gen size)]\n        (call-gen sized-gen rnd size)))))\n\n;; Combinators and helpers\n;; ---------------------------------------------------------------------------\n\n(defn resize\n  \"Create a new generator with `size` always bound to `n`.\"\n  [n generator]\n  (assert (generator? generator) \"Second arg to resize must be a generator\")\n  (core/let [{:keys [gen]} generator]\n    (make-gen\n     (fn [rnd _size]\n       (gen rnd n)))))\n\n(defn scale\n  \"Create a new generator that modifies the size parameter by the given function. Intended to\n   support generators with sizes that need to grow at different rates compared to the normal\n   linear scaling.\"\n  ([f generator]\n    (sized (fn [n] (resize (f n) generator)))))\n\n(defn choose\n  #?(:clj\n     \"Create a generator that returns long integers in the range `lower` to `upper`, inclusive.\"\n\n     :cljs\n     \"Create a generator that returns numbers in the range\n     `lower` to `upper`, inclusive.\")\n  [lower upper]\n  ;; cast to long to support doubles as arguments per TCHECK-73\n  (core/let #?(:clj\n          [lower (long lower)\n           upper (long upper)]\n\n          :cljs ;; does nothing, no long in cljs\n          [])\n    (make-gen\n     (fn [rnd _size]\n       (core/let [value (rand-range rnd lower upper)]\n         (rose/filter\n          #(and (>= % lower) (<= % upper))\n          (int-rose-tree value)))))))\n\n(defn one-of\n  \"Create a generator that randomly chooses a value from the list of\n  provided generators. Shrinks toward choosing an earlier generator,\n  as well as shrinking the value generated by the chosen generator.\n\n  Examples:\n\n      (one-of [gen/int gen/boolean (gen/vector gen/int)])\n\n  \"\n  [generators]\n  (assert (every? generator? generators)\n          \"Arg to one-of must be a collection of generators\")\n  (bind (choose 0 (dec (count generators)))\n        #(nth generators %)))\n\n(defn- pick\n  [[h & tail] n]\n  (core/let [[chance gen] h]\n    (if (<= n chance)\n      gen\n      (recur tail (- n chance)))))\n\n(defn frequency\n  \"Create a generator that chooses a generator from `pairs` based on the\n  provided likelihoods. The likelihood of a given generator being chosen is\n  its likelihood divided by the sum of all likelihoods\n\n  Examples:\n\n      (gen/frequency [[5 gen/int] [3 (gen/vector gen/int)] [2 gen/boolean]])\n  \"\n  [pairs]\n  (assert (every? (fn [[x g]] (and (number? x) (generator? g)))\n                  pairs)\n          \"Arg to frequency must be a list of [num generator] pairs\")\n  (core/let [total (apply + (core/map first pairs))]\n    (gen-bind (choose 1 total)\n              #(pick pairs (rose/root %)))))\n\n(defn elements\n  \"Create a generator that randomly chooses an element from `coll`.\n\n  Examples:\n\n      (gen/elements [:foo :bar :baz])\n  \"\n  [coll]\n  (assert (seq coll) \"elements cannot be called with an empty collection\")\n  (core/let [v (vec coll)]\n    (gen-bind (choose 0 (dec (count v)))\n              #(gen-pure (rose/fmap v %)))))\n\n(defn- such-that-helper\n  [max-tries pred gen tries-left rng size]\n  (if (zero? tries-left)\n    (throw (ex-info (str \"Couldn't satisfy such-that predicate after \"\n                         max-tries \" tries.\") {}))\n    (core/let [[r1 r2] (random/split rng)\n          value (call-gen gen r1 size)]\n      (if (pred (rose/root value))\n        (rose/filter pred value)\n        (recur max-tries pred gen (dec tries-left) r2 (inc size))))))\n\n(defn such-that\n  \"Create a generator that generates values from `gen` that satisfy predicate\n  `pred`. Care is needed to ensure there is a high chance `gen` will satisfy\n  `pred`. By default, `such-that` will try 10 times to generate a value that\n  satisfies the predicate. If no value passes this predicate after this number\n  of iterations, a runtime exception will be throw. You can pass an optional\n  third argument to change the number of times tried. Note also that each\n  time such-that retries, it will increase the size parameter.\n\n  Examples:\n\n      ;; generate non-empty vectors of integers\n      ;; (note, gen/not-empty does exactly this)\n      (gen/such-that not-empty (gen/vector gen/int))\n  \"\n  ([pred gen]\n   (such-that pred gen 10))\n  ([pred gen max-tries]\n   (assert (generator? gen) \"Second arg to such-that must be a generator\")\n   (make-gen\n     (fn [rand-seed size]\n       (such-that-helper max-tries pred gen max-tries rand-seed size)))))\n\n(defn not-empty\n  \"Modifies a generator so that it doesn't generate empty collections.\n\n  Examples:\n\n      ;; generate a vector of booleans, but never the empty vector\n      (gen/not-empty (gen/vector gen/boolean))\n  \"\n  [gen]\n  (assert (generator? gen) \"Arg to not-empty must be a generator\")\n  (such-that core/not-empty gen))\n\n(defn no-shrink\n  \"Create a new generator that is just like `gen`, except does not shrink\n  at all. This can be useful when shrinking is taking a long time or is not\n  applicable to the domain.\"\n  [gen]\n  (assert (generator? gen) \"Arg to no-shrink must be a generator\")\n  (gen-bind gen\n            (fn [rose]\n              (gen-pure (rose/make-rose (rose/root rose) [])))))\n\n(defn shrink-2\n  \"Create a new generator like `gen`, but will consider nodes for shrinking\n  even if their parent passes the test (up to one additional level).\"\n  [gen]\n  (assert (generator? gen) \"Arg to shrink-2 must be a generator\")\n  (gen-bind gen (comp gen-pure rose/collapse)))\n\n(def boolean\n  \"Generates one of `true` or `false`. Shrinks to `false`.\"\n  (elements [false true]))\n\n(defn tuple\n  \"Create a generator that returns a vector, whose elements are chosen\n  from the generators in the same position. The individual elements shrink\n  according to their generator, but the value will never shrink in count.\n\n  Examples:\n\n      (def t (tuple gen/int gen/boolean))\n      (sample t)\n      ;; => ([1 true] [2 true] [2 false] [1 false] [0 true] [-2 false] [-6 false]\n      ;; =>  [3 true] [-4 false] [9 true]))\n  \"\n  [& generators]\n  (assert (every? generator? generators)\n          \"Args to tuple must be generators\")\n  (gen-bind (gen-seq->seq-gen generators)\n            (fn [roses]\n              (gen-pure (rose/zip core/vector roses)))))\n\n(def int\n  \"Generates a positive or negative integer bounded by the generator's\n  `size` parameter.\n  (Really returns a long)\"\n  (sized (fn [size] (choose (- size) size))))\n\n(def nat\n  \"Generates natural numbers, starting at zero. Shrinks to zero.\"\n  (fmap #(Math/abs (long %)) int))\n\n(def pos-int\n  \"Generate positive integers bounded by the generator's `size` parameter.\"\n  nat)\n\n(def neg-int\n  \"Generate negative integers bounded by the generator's `size` parameter.\"\n  (fmap #(* -1 %) nat))\n\n(def s-pos-int\n  \"Generate strictly positive integers bounded by the generator's `size`\n   parameter.\"\n  (fmap inc nat))\n\n(def s-neg-int\n  \"Generate strictly negative integers bounded by the generator's `size`\n   parameter.\"\n  (fmap dec neg-int))\n\n(defn vector\n  \"Create a generator whose elements are chosen from `gen`. The count of the\n  vector will be bounded by the `size` generator parameter.\"\n  ([generator]\n   (assert (generator? generator) \"Arg to vector must be a generator\")\n   (gen-bind\n     (sized #(choose 0 %))\n     (fn [num-elements-rose]\n       (gen-bind (gen-seq->seq-gen\n                  (repeat (rose/root num-elements-rose)\n                          generator))\n                 (fn [roses]\n                   (gen-pure (rose/shrink core/vector\n                                          roses)))))))\n  ([generator num-elements]\n   (assert (generator? generator) \"First arg to vector must be a generator\")\n   (apply tuple (repeat num-elements generator)))\n  ([generator min-elements max-elements]\n   (assert (generator? generator) \"First arg to vector must be a generator\")\n   (gen-bind\n     (choose min-elements max-elements)\n     (fn [num-elements-rose]\n       (gen-bind (gen-seq->seq-gen\n                  (repeat (rose/root num-elements-rose)\n                          generator))\n                 (fn [roses]\n                   (gen-bind\n                     (gen-pure (rose/shrink core/vector\n                                            roses))\n                     (fn [rose]\n                       (gen-pure (rose/filter\n                                   (fn [v] (and (>= (count v) min-elements)\n                                                (<= (count v) max-elements))) rose))))))))))\n\n(defn list\n  \"Like `vector`, but generates lists.\"\n  [generator]\n  (assert (generator? generator) \"First arg to list must be a generator\")\n  (gen-bind (sized #(choose 0 %))\n            (fn [num-elements-rose]\n              (gen-bind (gen-seq->seq-gen\n                         (repeat (rose/root num-elements-rose)\n                                 generator))\n                        (fn [roses]\n                          (gen-pure (rose/shrink core/list\n                                                 roses)))))))\n\n(defn- swap\n  [coll [i1 i2]]\n  (assoc coll i2 (coll i1) i1 (coll i2)))\n\n(defn\n  ^{:added \"0.6.0\"}\n  shuffle\n  \"Create a generator that generates random permutations of `coll`. Shrinks\n  toward the original collection: `coll`. `coll` will be turned into a vector,\n  if it's not already.\"\n  [coll]\n  (core/let [index-gen (choose 0 (dec (count coll)))]\n    (fmap #(reduce swap (vec coll) %)\n          ;; a vector of swap instructions, with count between\n          ;; zero and 2 * count. This means that the average number\n          ;; of instructions is count, which should provide sufficient\n          ;; (though perhaps not 'perfect') shuffling. This still gives us\n          ;; nice, relatively quick shrinks.\n          (vector (tuple index-gen index-gen) 0 (* 2 (count coll))))))\n\n;; NOTE cljs: Comment out for now - David\n\n#?(:clj\n    (def byte\n      \"Generates `java.lang.Byte`s, using the full byte-range.\"\n      (fmap core/byte (choose Byte/MIN_VALUE Byte/MAX_VALUE))))\n\n#?(:clj\n    (def bytes\n      \"Generates byte-arrays.\"\n      (fmap core/byte-array (vector byte))))\n\n(defn hash-map\n  \"Like clojure.core/hash-map, except the values are generators.\n   Returns a generator that makes maps with the supplied keys and\n   values generated using the supplied generators.\n\n  Examples:\n\n    (gen/hash-map :a gen/boolean :b gen/nat)\n  \"\n  [& kvs]\n  (assert (even? (count kvs)))\n  (core/let [ks (take-nth 2 kvs)\n        vs (take-nth 2 (rest kvs))]\n    (assert (every? generator? vs)\n            \"Value args to hash-map must be generators\")\n    (fmap #(zipmap ks %)\n          (apply tuple vs))))\n\n;; Collections of distinct elements\n;; (has to be done in a low-level way (instead of with combinators)\n;;  and is subject to the same kind of failure as such-that)\n;; ---------------------------------------------------------------------------\n\n(defn ^:private transient-set-contains?\n  [s k]\n  #? (:clj\n      (.contains ^clojure.lang.ITransientSet s k)\n      :cljs\n      (some? (-lookup s k))))\n\n(defn ^:private coll-distinct-by*\n  \"Returns a rose tree.\"\n  [empty-coll key-fn shuffle-fn gen rng size num-elements min-elements max-tries]\n  {:pre [gen (:gen gen)]}\n  (loop [rose-trees (transient [])\n         s (transient #{})\n         rng rng\n         size size\n         tries 0]\n    (cond (and (= max-tries tries)\n               (< (count rose-trees) min-elements))\n          (throw (ex-info \"Couldn't generate enough distinct elements!\"\n                          {:gen gen\n                           :max-tries max-tries\n                           :num-elements num-elements\n                           :so-far (->> rose-trees\n                                        (persistent!)\n                                        (core/map rose/root))}))\n\n\n          (or (= max-tries tries)\n              (= (count rose-trees) num-elements))\n          (->> (persistent! rose-trees)\n               ;; we shuffle the rose trees so that we aren't biased\n               ;; toward generating \"smaller\" elements earlier in the\n               ;; collection (only applies to ordered collections)\n               ;;\n               ;; shuffling the rose trees is more efficient than\n               ;; (bind ... shuffle) because we only perform the\n               ;; shuffling once and we have no need to shrink the\n               ;; shufling.\n               (shuffle-fn rng)\n               (rose/shrink #(into empty-coll %&)))\n\n          :else\n          (core/let [[rng1 rng2] (random/split rng)\n                rose (call-gen gen rng1 size)\n                root (rose/root rose)\n                k (key-fn root)]\n            (if (transient-set-contains? s k)\n              (recur rose-trees s rng2 (inc size) (inc tries))\n              (recur (conj! rose-trees rose)\n                     (conj! s k)\n                     rng2\n                     size\n                     0))))))\n\n(defn ^:private distinct-by?\n  \"Like clojure.core/distinct? but takes a collection instead of varargs,\n  and returns true for empty collections.\"\n  [f coll]\n  (or (empty? coll)\n      (apply distinct? (core/map f coll))))\n\n(defn ^:private the-shuffle-fn\n  \"Returns a shuffled version of coll according to the rng.\n\n  Note that this is not a generator, it is just a utility function.\"\n  [rng coll]\n  (core/let [empty-coll (empty coll)\n        v (vec coll)\n        card (count coll)\n        dec-card (dec card)]\n    (into empty-coll\n          (first\n           (reduce (fn [[v rng] idx]\n                     (core/let [[rng1 rng2] (random/split rng)\n                           swap-idx (rand-range rng1 idx dec-card)]\n                       [(swap v [idx swap-idx]) rng2]))\n                   [v rng]\n                   (range card))))))\n\n(defn ^:private coll-distinct-by\n  [empty-coll key-fn allows-dupes? ordered? gen\n   {:keys [num-elements min-elements max-elements max-tries] :or {max-tries 10}}]\n  (core/let [shuffle-fn (if ordered?\n                     the-shuffle-fn\n                     (fn [_rng coll] coll))\n        hard-min-elements (or num-elements min-elements 1)]\n    (if num-elements\n      (core/let [size-pred #(= num-elements (count %))]\n        (assert (and (nil? min-elements) (nil? max-elements)))\n        (make-gen\n         (fn [rng gen-size]\n           (rose/filter\n            (if allows-dupes?\n              ;; is there a smarter way to do the shrinking than checking\n              ;; the distinctness of the entire collection at each\n              ;; step?\n              (every-pred size-pred #(distinct-by? key-fn %))\n              size-pred)\n            (coll-distinct-by* empty-coll key-fn shuffle-fn gen rng gen-size\n                               num-elements hard-min-elements max-tries)))))\n      (core/let [min-elements (or min-elements 0)\n                 size-pred (if max-elements\n                             #(<= min-elements (count %) max-elements)\n                             #(<= min-elements (count %)))]\n        (gen-bind\n         (if max-elements\n           (choose min-elements max-elements)\n           (sized #(choose min-elements (+ min-elements %))))\n         (fn [num-elements-rose]\n           (core/let [num-elements (rose/root num-elements-rose)]\n             (make-gen\n              (fn [rng gen-size]\n                (rose/filter\n                 (if allows-dupes?\n                   ;; same comment as above\n                   (every-pred size-pred #(distinct-by? key-fn %))\n                   size-pred)\n                 (coll-distinct-by* empty-coll key-fn shuffle-fn gen rng gen-size\n                                    num-elements hard-min-elements max-tries)))))))))))\n\n\n;; I tried to reduce the duplication in these docstrings with a macro,\n;; but couldn't make it work in cljs.\n\n(defn vector-distinct\n  \"Generates a vector of elements from the given generator, with the\n  guarantee that the elements will be distinct.\n\n  If the generator cannot or is unlikely to produce enough distinct\n  elements, this generator will fail in the same way as such-that.\n\n  Available options:\n\n    :num-elements  the fixed size of generated vectors\n    :min-elements  the min size of generated vectors\n    :max-elements  the max size of generated vectors\n    :max-tries     the number of times the generator will be tried before\n                   failing when it does not produce distinct elements\n                   (default 10)\"\n  ([gen] (vector-distinct gen {}))\n  ([gen opts]\n   (assert (generator? gen) \"First arg to vector-distinct must be a generator!\")\n   (coll-distinct-by [] identity true true gen opts)))\n\n(defn list-distinct\n  \"Generates a list of elements from the given generator, with the\n  guarantee that the elements will be distinct.\n\n  If the generator cannot or is unlikely to produce enough distinct\n  elements, this generator will fail in the same way as such-that.\n\n  Available options:\n\n    :num-elements  the fixed size of generated vectors\n    :min-elements  the min size of generated vectors\n    :max-elements  the max size of generated vectors\n    :max-tries     the number of times the generator will be tried before\n                   failing when it does not produce distinct elements\n                   (default 10)\"\n  ([gen] (list-distinct gen {}))\n  ([gen opts]\n   (assert (generator? gen) \"First arg to list-distinct must be a generator!\")\n   (coll-distinct-by () identity true true gen opts)))\n\n(defn vector-distinct-by\n  \"Generates a vector of elements from the given generator, with the\n  guarantee that (map key-fn the-vector) will be distinct.\n\n  If the generator cannot or is unlikely to produce enough distinct\n  elements, this generator will fail in the same way as such-that.\n\n  Available options:\n\n    :num-elements  the fixed size of generated vectors\n    :min-elements  the min size of generated vectors\n    :max-elements  the max size of generated vectors\n    :max-tries     the number of times the generator will be tried before\n                   failing when it does not produce distinct elements\n                   (default 10)\"\n  ([key-fn gen] (vector-distinct-by key-fn gen {}))\n  ([key-fn gen opts]\n   (assert (generator? gen) \"First arg to vector-distinct-by must be a generator!\")\n   (coll-distinct-by [] key-fn true true gen opts)))\n\n(defn list-distinct-by\n  \"Generates a list of elements from the given generator, with the\n  guarantee that (map key-fn the-list) will be distinct.\n\n  If the generator cannot or is unlikely to produce enough distinct\n  elements, this generator will fail in the same way as such-that.\n\n  Available options:\n\n    :num-elements  the fixed size of generated vectors\n    :min-elements  the min size of generated vectors\n    :max-elements  the max size of generated vectors\n    :max-tries     the number of times the generator will be tried before\n                   failing when it does not produce distinct elements\n                   (default 10)\"\n  ([key-fn gen] (list-distinct-by key-fn gen {}))\n  ([key-fn gen opts]\n   (assert (generator? gen) \"First arg to list-distinct-by must be a generator!\")\n   (coll-distinct-by () key-fn true true gen opts)))\n\n(defn set\n  \"Generates a set of elements from the given generator.\n\n  If the generator cannot or is unlikely to produce enough distinct\n  elements, this generator will fail in the same way as such-that.\n\n  Available options:\n\n    :num-elements  the fixed size of generated vectors\n    :min-elements  the min size of generated vectors\n    :max-elements  the max size of generated vectors\n    :max-tries     the number of times the generator will be tried before\n                   failing when it does not produce distinct elements\n                   (default 10)\"\n  ([gen] (set gen {}))\n  ([gen opts]\n   (assert (generator? gen) \"First arg to set must be a generator!\")\n   (coll-distinct-by #{} identity false false gen opts)))\n\n(defn sorted-set\n  \"Generates a sorted set of elements from the given generator.\n\n  If the generator cannot or is unlikely to produce enough distinct\n  elements, this generator will fail in the same way as such-that.\n\n  Available options:\n\n    :num-elements  the fixed size of generated vectors\n    :min-elements  the min size of generated vectors\n    :max-elements  the max size of generated vectors\n    :max-tries     the number of times the generator will be tried before\n                   failing when it does not produce distinct elements\n                   (default 10)\"\n  ([gen] (sorted-set gen {}))\n  ([gen opts]\n   (assert (generator? gen) \"First arg to sorted-set must be a generator!\")\n   (coll-distinct-by (core/sorted-set) identity false false gen opts)))\n\n(defn map\n  \"Create a generator that generates maps, with keys chosen from\n  `key-gen` and values chosen from `val-gen`.\n\n  If the key generator cannot or is unlikely to produce enough distinct\n  elements, this generator will fail in the same way as such-that.\n\n  Available options:\n\n    :num-elements  the fixed size of generated vectors\n    :min-elements  the min size of generated vectors\n    :max-elements  the max size of generated vectors\n    :max-tries     the number of times the generator will be tried before\n                   failing when it does not produce distinct elements\n                   (default 10)\"\n  ([key-gen val-gen] (map key-gen val-gen {}))\n  ([key-gen val-gen opts]\n   (coll-distinct-by {} first false false (tuple key-gen val-gen) opts)))\n\n;; large integers\n;; ---------------------------------------------------------------------------\n\n;; This approach has a few distribution edge cases, but is pretty good\n;; for expected uses and is way better than nothing.\n\n(def ^:private gen-raw-long\n  \"Generates a single uniformly random long, does not shrink.\"\n  (make-gen (fn [rnd _size]\n              (rose/pure (random/rand-long rnd)))))\n\n(def ^:private MAX_INTEGER\n  #?(:clj Long/MAX_VALUE :cljs (dec (apply * (repeat 53 2)))))\n(def ^:private MIN_INTEGER\n  #?(:clj Long/MIN_VALUE :cljs (- MAX_INTEGER)))\n\n(defn ^:private abs\n  [x]\n  #?(:clj (Math/abs (long x)) :cljs (Math/abs x)))\n\n(defn ^:private long->large-integer\n  [bit-count x min max]\n  (loop [res (-> x\n                 (#?(:clj bit-shift-right :cljs .shiftRight)\n                    (- 64 bit-count))\n                 #?(:cljs .toNumber)\n                 ;; so we don't get into an infinite loop bit-shifting\n                 ;; -1\n                 (cond-> (zero? min) (abs)))]\n    (if (<= min res max)\n      res\n      (core/let [res' (- res)]\n        (if (<= min res' max)\n          res'\n          (recur #?(:clj (bit-shift-right res 1)\n                    ;; emulating bit-shift-right\n                    :cljs (-> res\n                              (cond-> (odd? res)\n                                ((if (neg? res) inc dec)))\n                              (/ 2)))))))))\n\n(defn ^:private large-integer**\n  \"Like large-integer*, but assumes range includes zero.\"\n  [min max]\n  (sized (fn [size]\n           (core/let [size (core/max size 1) ;; no need to worry about size=0\n                 max-bit-count (core/min size #?(:clj 64 :cljs 54))]\n             (gen-fmap (fn [rose]\n                         (core/let [[bit-count x] (rose/root rose)]\n                           (int-rose-tree (long->large-integer bit-count x min max))))\n                       (tuple (choose 1 max-bit-count)\n                              gen-raw-long))))))\n\n\n(defn large-integer*\n  \"Like large-integer, but accepts options:\n\n    :min  the minimum integer (inclusive)\n    :max  the maximum integer (inclusive)\n\n  Both :min and :max are optional.\"\n  [{:keys [min max]}]\n  (core/let [min (or min MIN_INTEGER)\n        max (or max MAX_INTEGER)]\n    (assert (<= min max))\n    (such-that #(<= min % max)\n               (if (<= min 0 max)\n                 (large-integer** min max)\n                 (if (< max 0)\n                   (fmap #(+ max %) (large-integer** (- min max) 0))\n                   (fmap #(+ min %) (large-integer** 0 (- max min))))))))\n\n(def large-integer\n  \"Generates a platform-native integer from the full available range\n  (in clj, 64-bit Longs, and in cljs, numbers between -(2^53 - 1) and\n  (2^53 - 1)).\n\n  Use large-integer* for more control.\"\n  (large-integer* {}))\n\n\n;; doubles\n;; ---------------------------------------------------------------------------\n\n\n;; This code is a lot more complex than any reasonable person would\n;; expect, for two reasons:\n;;\n;; 1) I wanted the generator to start with simple values and grow with\n;; the size parameter, as well as shrink back to simple values. I\n;; decided to define \"simple\" as numbers with simpler (closer to 0)\n;; exponents, with simpler fractional parts (fewer lower-level bits\n;; set), and with positive being simpler than negative. I also wanted\n;; to take a optional min/max parameters, which complicates the hell\n;; out of things\n;;\n;; 2) It works in CLJS as well, which has fewer utility functions for\n;; doubles, and I wanted it to work exactly the same way in CLJS just\n;; to validate the whole cross-platform situation. It should generate\n;; the exact same numbers on both platforms.\n;;\n;; Some of the lower level stuff could probably be less messy and\n;; faster, especially for CLJS.\n\n(def ^:private POS_INFINITY #?(:clj Double/POSITIVE_INFINITY, :cljs (.-POSITIVE_INFINITY js/Number)))\n(def ^:private NEG_INFINITY #?(:clj Double/NEGATIVE_INFINITY, :cljs (.-NEGATIVE_INFINITY js/Number)))\n(def ^:private MAX_POS_VALUE #?(:clj Double/MAX_VALUE, :cljs (.-MAX_VALUE js/Number)))\n(def ^:private MIN_NEG_VALUE (- MAX_POS_VALUE))\n(def ^:private NAN #?(:clj Double/NaN, :cljs (.-NaN js/Number)))\n\n(defn ^:private uniform-integer\n  \"Generates an integer uniformly in the range 0..(2^bit-count-1).\"\n  [bit-count]\n  {:assert [(<= 0 bit-count 52)]}\n  (if (<= bit-count 32)\n    ;; the case here is just for cljs\n    (choose 0 (case (long bit-count)\n                32 0xffffffff\n                31 0x7fffffff\n                (-> 1 (bit-shift-left bit-count) dec)))\n    (fmap (fn [[upper lower]]\n            #? (:clj\n                (-> upper (bit-shift-left 32) (+ lower))\n\n                :cljs\n                (-> upper (* 0x100000000) (+ lower))))\n          (tuple (uniform-integer (- bit-count 32))\n                 (uniform-integer 32)))))\n\n(defn ^:private scalb\n  [x exp]\n  #?(:clj (Math/scalb ^double x ^int exp)\n     :cljs (* x (.pow js/Math 2 exp))))\n\n(defn ^:private fifty-two-bit-reverse\n  \"Bit-reverses an integer in the range [0, 2^52).\"\n  [n]\n  #? (:clj\n      (-> n (Long/reverse) (unsigned-bit-shift-right 12))\n\n      :cljs\n      (loop [out 0\n             n n\n             out-shifter (Math/pow 2 52)]\n        (if (< n 1)\n          (* out out-shifter)\n          (recur (-> out (* 2) (+ (bit-and n 1)))\n                 (/ n 2)\n                 (/ out-shifter 2))))))\n\n(def ^:private backwards-shrinking-significand\n  \"Generates a 52-bit non-negative integer that shrinks toward having\n  fewer lower-order bits (and shrinks to 0 if possible).\"\n  (fmap fifty-two-bit-reverse\n        (sized (fn [size]\n                 (gen-bind (choose 0 (min size 52))\n                           (fn [rose]\n                             (uniform-integer (rose/root rose))))))))\n\n(defn ^:private get-exponent\n  [x]\n  #? (:clj\n      (Math/getExponent ^Double x)\n\n      :cljs\n      (if (zero? x)\n        -1023\n        (core/let [x (Math/abs x)\n\n                   res\n                   (Math/floor (* (Math/log x) (.-LOG2E js/Math)))\n\n                   t (scalb x (- res))]\n          (cond (< t 1) (dec res)\n                (<= 2 t) (inc res)\n                :else res)))))\n\n(defn ^:private double-exp-and-sign\n  \"Generates [exp sign], where exp is in [-1023, 1023] and sign is 1\n  or -1. Only generates values for exp and sign for which there are\n  doubles within the given bounds.\"\n  [lower-bound upper-bound]\n  (letfn [(gen-exp [lb ub]\n            (sized (fn [size]\n                     (core/let [qs8 (bit-shift-left 1 (quot (min 200 size) 8))]\n                       (cond (<= lb 0 ub)\n                             (choose (max lb (- qs8)) (min ub qs8))\n\n                             (< ub 0)\n                             (choose (max lb (- ub qs8)) ub)\n\n                             :else\n                             (choose lb (min ub (+ lb qs8))))))))]\n    (if (and (nil? lower-bound)\n             (nil? upper-bound))\n      (tuple (gen-exp -1023 1023)\n             (elements [1.0 -1.0]))\n      (core/let [lower-bound (or lower-bound MIN_NEG_VALUE)\n                 upper-bound (or upper-bound MAX_POS_VALUE)\n                 lbexp (max -1023 (get-exponent lower-bound))\n                 ubexp (max -1023 (get-exponent upper-bound))]\n        (cond (<= 0.0 lower-bound)\n              (tuple (gen-exp lbexp ubexp)\n                     (return 1.0))\n\n              (<= upper-bound 0.0)\n              (tuple (gen-exp ubexp lbexp)\n                     (return -1.0))\n\n              :else\n              (fmap (fn [[exp sign :as pair]]\n                      (if (or (and (neg? sign) (< lbexp exp))\n                              (and (pos? sign) (< ubexp exp)))\n                        [exp (- sign)]\n                        pair))\n                    (tuple\n                     (gen-exp -1023 (max ubexp lbexp))\n                     (elements [1.0 -1.0]))))))))\n\n(defn ^:private block-bounds\n  \"Returns [low high], the smallest and largest numbers in the given\n  range.\"\n  [exp sign]\n  (if (neg? sign)\n    (core/let [[low high] (block-bounds exp (- sign))]\n      [(- high) (- low)])\n    (if (= -1023 exp)\n      [0.0 (-> 1.0 (scalb 52) dec (scalb -1074))]\n      [(scalb 1.0 exp)\n       (-> 1.0 (scalb 52) dec (scalb (- exp 51)))])))\n\n(defn ^:private double-finite\n  [ lower-bound upper-bound]\n  {:pre [(or (nil? lower-bound)\n             (nil? upper-bound)\n             (<= lower-bound upper-bound))]}\n  (core/let [pred (if lower-bound\n                    (if upper-bound\n                      #(<= lower-bound % upper-bound)\n                      #(<= lower-bound %))\n                    (if upper-bound\n                      #(<= % upper-bound)))\n\n             gen\n             (fmap (fn [[[exp sign] significand]]\n                     (core/let [ ;; 1.0 <= base < 2.0\n                                base (inc (/ significand (Math/pow 2 52)))\n                                x (-> base (scalb exp) (* sign))]\n                       (if (or (nil? pred) (pred x))\n                         x\n                         ;; Scale things a bit when we have a partial range\n                         ;; to deal with. It won't be great for generating\n                         ;; simple numbers, but oh well.\n                         (core/let [[low high] (block-bounds exp sign)\n\n                                    block-lb (cond-> low  lower-bound (max lower-bound))\n                                    block-ub (cond-> high upper-bound (min upper-bound))\n                                    x (+ block-lb (* (- block-ub block-lb) (- base 1)))]\n                           (-> x (min block-ub) (max block-lb))))))\n                   (tuple (double-exp-and-sign lower-bound upper-bound)\n                          backwards-shrinking-significand))]\n    ;; wrapping in the such-that is necessary for staying in bounds\n    ;; during shrinking\n    (cond->> gen pred (such-that pred))))\n\n(defn double*\n  \"Generates a 64-bit floating point number. Options:\n\n    :infinite? - whether +/- infinity can be generated (default true)\n    :NaN?      - whether NaN can be generated (default true)\n    :min       - minimum value (inclusive, default none)\n    :max       - maximum value (inclusive, default none)\n\n  Note that the min/max options must be finite numbers. Supplying a\n  min precludes -Infinity, and supplying a max precludes +Infinity.\"\n  [{:keys [infinite? NaN? min max]\n    :or {infinite? true, NaN? true}}]\n  (core/let [frequency-arg (cond-> [[95 (double-finite min max)]]\n\n                             (if (nil? min)\n                               (or (nil? max) (<= 0.0 max))\n                               (if (nil? max)\n                                 (<= min 0.0)\n                                 (<= min 0.0 max)))\n                             (conj\n                              ;; Add zeros here as a special case, since\n                              ;; the `finite` code considers zeros rather\n                              ;; complex (as they have a -1023 exponent)\n                              ;;\n                              ;; I think most uses can't distinguish 0.0\n                              ;; from -0.0, but seems worth throwing both\n                              ;; in just in case.\n                              [1 (return 0.0)]\n                              [1 (return -0.0)])\n\n                             (and infinite? (nil? max))\n                             (conj [1 (return POS_INFINITY)])\n\n                             (and infinite? (nil? min))\n                             (conj [1 (return NEG_INFINITY)])\n\n                             NaN? (conj [1 (return NAN)]))]\n    (if (= 1 (count frequency-arg))\n      (-> frequency-arg first second)\n      (frequency frequency-arg))))\n\n(def double\n  \"Generates 64-bit floating point numbers from the entire range,\n  including +/- infinity and NaN. Use double* for more control.\"\n  (double* {}))\n\n\n;; Characters & Strings\n;; ---------------------------------------------------------------------------\n\n(def char\n  \"Generates character from 0-255.\"\n  (fmap core/char (choose 0 255)))\n\n(def char-ascii\n  \"Generate only ascii character.\"\n  (fmap core/char (choose 32 126)))\n\n(def char-alphanumeric\n  \"Generate alphanumeric characters.\"\n  (fmap core/char\n        (one-of [(choose 48 57)\n                 (choose 65 90)\n                 (choose 97 122)])))\n\n(def ^{:deprecated \"0.6.0\"}\n  char-alpha-numeric\n  \"Deprecated - use char-alphanumeric instead.\n\n  Generate alphanumeric characters.\"\n  char-alphanumeric)\n\n(def char-alpha\n  \"Generate alpha characters.\"\n  (fmap core/char\n        (one-of [(choose 65 90)\n                 (choose 97 122)])))\n\n(def ^{:private true} char-symbol-special\n  \"Generate non-alphanumeric characters that can be in a symbol.\"\n  (elements [\\* \\+ \\! \\- \\_ \\?]))\n\n(def ^{:private true} char-keyword-rest\n  \"Generate characters that can be the char following first of a keyword.\"\n  (frequency [[2 char-alphanumeric]\n              [1 char-symbol-special]]))\n\n(def ^{:private true} char-keyword-first\n  \"Generate characters that can be the first char of a keyword.\"\n  (frequency [[2 char-alpha]\n              [1 char-symbol-special]]))\n\n(def string\n  \"Generate strings. May generate unprintable characters.\"\n  (fmap clojure.string/join (vector char)))\n\n(def string-ascii\n  \"Generate ascii strings.\"\n  (fmap clojure.string/join (vector char-ascii)))\n\n(def string-alphanumeric\n  \"Generate alphanumeric strings.\"\n  (fmap clojure.string/join (vector char-alphanumeric)))\n\n(def ^{:deprecated \"0.6.0\"}\n  string-alpha-numeric\n  \"Deprecated - use string-alphanumeric instead.\n\n  Generate alphanumeric strings.\"\n  string-alphanumeric)\n\n(defn- digit?\n  [d]\n  #?(:clj  (Character/isDigit ^Character d)\n     :cljs (gstring/isNumeric d)))\n\n(defn- +-or---digit?\n  \"Returns true if c is \\\\+ or \\\\- and d is non-nil and a digit.\n\n  Symbols that start with +3 or -2 are not readable because they look\n  like numbers.\"\n  [c d]\n  (core/boolean (and d\n                     (or (#?(:clj = :cljs identical?) \\+ c)\n                         (#?(:clj = :cljs identical?) \\- c))\n                     (digit? d))))\n\n(def ^{:private true} namespace-segment\n  \"Generate the segment of a namespace.\"\n  (->> (tuple char-keyword-first (vector char-keyword-rest))\n       (such-that (fn [[c [d]]] (not (+-or---digit? c d))))\n       (fmap (fn [[c cs]] (clojure.string/join (cons c cs))))))\n\n(def ^{:private true} namespace\n  \"Generate a namespace (or nil for no namespace).\"\n  (->> (vector namespace-segment)\n       (fmap (fn [v] (when (seq v)\n                       (clojure.string/join \".\" v))))))\n\n(def ^{:private true} keyword-segment-rest\n  \"Generate segments of a keyword (between \\\\:)\"\n  (->> (tuple char-keyword-rest (vector char-keyword-rest))\n       (fmap (fn [[c cs]] (clojure.string/join (cons c cs))))))\n\n(def ^{:private true} keyword-segment-first\n  \"Generate segments of a keyword that can be first (between \\\\:)\"\n  (->> (tuple char-keyword-first (vector char-keyword-rest))\n       (fmap (fn [[c cs]] (clojure.string/join (cons c cs))))))\n\n(def keyword\n  \"Generate keywords without namespaces.\"\n  (->> (tuple keyword-segment-first (vector keyword-segment-rest))\n       (fmap (fn [[c cs]]\n               (core/keyword (clojure.string/join \":\" (cons c cs)))))))\n\n(def\n  ^{:added \"0.5.9\"}\n  keyword-ns\n  \"Generate keywords with optional namespaces.\"\n  (->> (tuple namespace char-keyword-first (vector char-keyword-rest))\n       (fmap (fn [[ns c cs]]\n               (core/keyword ns (clojure.string/join (cons c cs)))))))\n\n(def ^{:private true} char-symbol-first\n  (frequency [[10 char-alpha]\n              [5 char-symbol-special]\n              [1 (return \\.)]]))\n\n(def ^{:private true} char-symbol-rest\n  (frequency [[10 char-alphanumeric]\n              [5 char-symbol-special]\n              [1 (return \\.)]]))\n\n(def symbol\n  \"Generate symbols without namespaces.\"\n  (frequency [[100 (->> (tuple char-symbol-first (vector char-symbol-rest))\n                        (such-that (fn [[c [d]]] (not (+-or---digit? c d))))\n                        (fmap (fn [[c cs]] (core/symbol (clojure.string/join (cons c cs))))))]\n              [1 (return '/)]]))\n\n(def\n  ^{:added \"0.5.9\"}\n  symbol-ns\n  \"Generate symbols with optional namespaces.\"\n  (frequency [[100 (->> (tuple namespace char-symbol-first (vector char-symbol-rest))\n                        (such-that (fn [[_ c [d]]] (not (+-or---digit? c d))))\n                        (fmap (fn [[ns c cs]] (core/symbol ns (clojure.string/join (cons c cs))))))]\n              [1 (return '/)]]))\n\n(def ratio\n  \"Generates a `clojure.lang.Ratio`. Shrinks toward 0. Not all values generated\n  will be ratios, as many values returned by `/` are not ratios.\"\n  (fmap\n    (fn [[a b]] (/ a b))\n    (tuple int\n           (such-that (complement zero?) int))))\n\n(def uuid\n  \"Generates a random type-4 UUID. Does not shrink.\"\n  (no-shrink\n   #?(:clj\n      ;; this could be done with combinators, but doing it low-level\n      ;; seems to be 10x faster\n      (make-gen\n       (fn [rng _size]\n         (core/let [[r1 r2] (random/split rng)\n                    x1 (-> (random/rand-long r1)\n                           (bit-and -45057)\n                           (bit-or 0x4000))\n                    x2 (-> (random/rand-long r2)\n                           (bit-or -9223372036854775808)\n                           (bit-and -4611686018427387905))]\n           (rose/make-rose\n            (java.util.UUID. x1 x2)\n            []))))\n\n      :cljs\n      ;; this could definitely be optimized so that it doesn't require\n      ;; generating 31 numbers\n      (fmap (fn [nibbles]\n              (letfn [(hex [idx] (.toString (nibbles idx) 16))]\n                (core/let [rhex (-> (nibbles 15) (bit-and 3) (+ 8) (.toString 16))]\n                  (core/uuid (str (hex 0)  (hex 1)  (hex 2)  (hex 3)\n                                  (hex 4)  (hex 5)  (hex 6)  (hex 7)  \"-\"\n                                  (hex 8)  (hex 9)  (hex 10) (hex 11) \"-\"\n                                  \"4\"      (hex 12) (hex 13) (hex 14) \"-\"\n                                  rhex     (hex 16) (hex 17) (hex 18) \"-\"\n                                  (hex 19) (hex 20) (hex 21) (hex 22)\n                                  (hex 23) (hex 24) (hex 25) (hex 26)\n                                  (hex 27) (hex 28) (hex 29) (hex 30))))))\n            (vector (choose 0 15) 31)))))\n\n(def simple-type\n  (one-of [int large-integer double char string ratio boolean keyword\n           keyword-ns symbol symbol-ns uuid]))\n\n(def simple-type-printable\n  (one-of [int large-integer double char-ascii string-ascii ratio boolean\n           keyword keyword-ns symbol symbol-ns uuid]))\n\n(defn container-type\n  [inner-type]\n  (one-of [(vector inner-type)\n           (list inner-type)\n           (map inner-type inner-type)]))\n\n(defn- recursive-helper\n  [container-gen-fn scalar-gen scalar-size children-size height]\n  (if (zero? height)\n    (resize scalar-size scalar-gen)\n    (resize children-size\n            (container-gen-fn\n              (recursive-helper\n                container-gen-fn scalar-gen\n                scalar-size children-size (dec height))))))\n\n(defn\n  ^{:added \"0.5.9\"}\n  recursive-gen\n  \"This is a helper for writing recursive (tree-shaped) generators. The first\n  argument should be a function that takes a generator as an argument, and\n  produces another generator that 'contains' that generator. The vector function\n  in this namespace is a simple example. The second argument is a scalar\n  generator, like boolean. For example, to produce a tree of booleans:\n\n    (gen/recursive-gen gen/vector gen/boolean)\n\n  Vectors or maps either recurring or containing booleans or integers:\n\n    (gen/recursive-gen (fn [inner] (gen/one-of [(gen/vector inner)\n                                                (gen/map inner inner)]))\n                       (gen/one-of [gen/boolean gen/int]))\n  \"\n  [container-gen-fn scalar-gen]\n  (assert (generator? scalar-gen)\n          \"Second arg to recursive-gen must be a generator\")\n  (sized (fn [size]\n           (bind (choose 1 5)\n                 (fn [height] (core/let [children-size (Math/pow size (/ 1 height))]\n                                (recursive-helper container-gen-fn scalar-gen size\n                                                  children-size height)))))))\n\n(def any\n  \"A recursive generator that will generate many different, often nested, values\"\n  (recursive-gen container-type simple-type))\n\n(def any-printable\n  \"Like any, but avoids characters that the shell will interpret as actions,\n  like 7 and 14 (bell and alternate character set command)\"\n  (recursive-gen container-type simple-type-printable))\n\n\n;; Macros\n;; ---------------------------------------------------------------------------\n\n(defmacro let\n  \"Macro for building generators using values from other generators.\n  Uses a binding vector with the same syntax as clojure.core/let,\n  where the right-hand side of the binding pairs are generators, and\n  the left-hand side are names (or destructuring forms) for generated\n  values.\n\n  Subsequent generator expressions can refer to the previously bound\n  values, in the same way as clojure.core/let.\n\n  The body of the let can be either a value or a generator, and does\n  the expected thing in either case. In this way let provides the\n  functionality of both `bind` and `fmap`.\n\n  Examples:\n\n    (gen/let [strs (gen/not-empty (gen/list gen/string))\n              s (gen/elements strs)]\n      {:some-strings strs\n       :one-of-those-strings s})\n\n    ;; generates collections of \\\"users\\\" that have integer IDs\n    ;; from 0...N-1, but are in a random order\n    (gen/let [users (gen/list (gen/hash-map :name gen/string-ascii\n                                            :age gen/nat))]\n      (->> users\n           (map #(assoc %2 :id %1) (range))\n           (gen/shuffle)))\"\n  [bindings & body]\n  (assert (vector? bindings)\n          \"First arg to gen/let must be a vector of bindings.\")\n  (assert (even? (count bindings))\n          \"gen/let requires an even number of forms in binding vector\")\n  (if (empty? bindings)\n    `(core/let [val# (do ~@body)]\n       (if (generator? val#)\n         val#\n         (return val#)))\n    (core/let [[binding gen & more] bindings]\n      `(bind ~gen (fn [~binding] (let [~@more] ~@body))))))\n"],"mappings":"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","names":["this__4301__auto__","k__4302__auto__","k11022","G__11027","cljs.core/Keyword","gen","cljs.core.get.cljs$core$IFn$_invoke$arity$3","__extmap","else__4304__auto__","cljs.core.reduce.cljs$core$IFn$_invoke$arity$3","p__11028","cljs.core.nth.cljs$core$IFn$_invoke$arity$3","vec__11029","f__4321__auto__","ret__4323__auto__","k__4324__auto__","v__4325__auto__","init__4322__auto__","this__4320__auto__","cljs.core/pr-sequential-writer","writer__4316__auto__","opts__4317__auto__","keyval__4319__auto__","pr-pair__4318__auto__","cljs.core.concat.cljs$core$IFn$_invoke$arity$2","cljs.core/PersistentVector","cljs.core/RecordIter","G__11021","cljs.core/-iterator","cljs.core/nil-iter","__meta","__hash","cljs.core/count","h__4159__auto__","cljs.core/hash-unordered-coll","coll__4298__auto__","fexpr__11046","this__4297__auto__","other11024","this11023","cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2","cljs.core/contains?","k__4311__auto__","cljs.core.dissoc.cljs$core$IFn$_invoke$arity$2","cljs.core/-with-meta","cljs.core.into.cljs$core$IFn$_invoke$arity$2","this__4310__auto__","cljs.core/not-empty","cljs.core/keyword-identical?","k__4309__auto__","expr__11057","pred__11056","G__11059","G__11060","cljs.core.assoc.cljs$core$IFn$_invoke$arity$3","cljs.core/seq","cljs.core/MapEntry","cljs.core/vector?","entry__4307__auto__","this__4306__auto__","cljs.core._nth.cljs$core$IFn$_invoke$arity$2","cljs.core/-conj","clojure.test.check.generators/Generator","cljs.core/List","cljs.core/-write","writer__4345__auto__","G__11025","cljs.core/record?","G__11063","extmap__4340__auto__","clojure.test.check.generators/->Generator","clojure.test.check.generators/map->Generator","clojure.test.check.generators/generator?","x","clojure.test.check.generators/make-gen","generator-fn","p__11068","map__11069","cljs.core/PROTOCOL_SENTINEL","cljs.core.apply.cljs$core$IFn$_invoke$arity$2","cljs.core/hash-map","cljs.core.get.cljs$core$IFn$_invoke$arity$2","clojure.test.check.generators/call-gen","rnd","size","clojure.test.check.generators/gen-pure","value","p__11074","map__11075","clojure.test.check.generators/gen-fmap","G__11078","k","h","p__11079","map__11080","clojure.test.check.generators/gen-bind","vec__11082","map__11085","clojure.test.check.random/split","r1","inner","result","r2","clojure.test.check.generators/lazy-random-states","cljs.core/LazySeq","vec__11090","rr","cljs.core/cons","clojure.test.check.generators/gen-seq->seq-gen","cljs.core.mapv.cljs$core$IFn$_invoke$arity$3","p1__11093#","p2__11094#","gens","clojure.test.check.random/split-n","clojure.test.check.generators/fmap","js/Error","p1__11095#","clojure.test.check.rose-tree/fmap","f","clojure.test.check.generators/return","clojure.test.check.rose-tree/pure","clojure.test.check.generators/bind-helper","clojure.test.check.rose-tree/join","p1__11102#","rose","clojure.test.check.generators/bind","generator","clojure.test.check.generators/make-size-range-seq","cljs.core/cycle","cljs.core.range.cljs$core$IFn$_invoke$arity$2","max-size","G__11110","clojure.test.check.generators/sample-seq","clojure.test.check.generators.sample_seq.cljs$core$IFn$_invoke$arity$2","clojure.test.check.random.make_random.cljs$core$IFn$_invoke$arity$0","cljs.core.map.cljs$core$IFn$_invoke$arity$3","clojure.test.check.rose-tree/root","p1__11107#","p2__11108#","r","size-seq","G__11114","clojure.test.check.generators/sample","clojure.test.check.generators.sample.cljs$core$IFn$_invoke$arity$2","cljs.core.take.cljs$core$IFn$_invoke$arity$2","num-samples","clojure.test.check.generators.sample_seq.cljs$core$IFn$_invoke$arity$1","G__11116","clojure.test.check.generators/generate","clojure.test.check.generators.generate.cljs$core$IFn$_invoke$arity$2","rng","clojure.test.check.generators/halfs","cljs.core.take_while.cljs$core$IFn$_invoke$arity$2","p1__11118#","cljs.core.not_EQ_.cljs$core$IFn$_invoke$arity$2","cljs.core/iterate","p1__11119#","cljs.core/quot","n","clojure.test.check.generators/shrink-int","cljs.core.map.cljs$core$IFn$_invoke$arity$2","p1__11120#","integer","clojure.test.check.generators/int-rose-tree","clojure.test.check.rose-tree/make-rose","clojure.test.check.generators/calc-long","cljs.core/long","G__11122","Math/floor","lower","factor","upper","clojure.test.check.generators/rand-range","clojure.test.check.random/rand-double","clojure.test.check.generators/sized","sized-gen","clojure.test.check.generators/resize","map__11124","clojure.test.check.generators/scale","clojure.test.check.generators/choose","clojure.test.check.rose-tree/filter","p1__11127#","clojure.test.check.generators/one-of","cljs.core/every?","generators","p1__11128#","cljs.core.nth.cljs$core$IFn$_invoke$arity$2","p__11129","vec__11130","cljs.core/first","seq__11131","cljs.core/next","first__11132","clojure.test.check.generators/pick","vec__11133","chance","tail","clojure.test.check.generators/frequency","p__11137","vec__11138","g","pairs","cljs.core/+","total","p1__11136#","clojure.test.check.generators/elements","coll","cljs.core/vec","v","p1__11142#","clojure.test.check.generators/such-that-helper","tries-left","cljs.core.ex_info.cljs$core$IFn$_invoke$arity$2","max-tries","vec__11154","G__11157","pred","G__11166","clojure.test.check.generators/such-that","clojure.test.check.generators.such_that.cljs$core$IFn$_invoke$arity$3","rand-seed","clojure.test.check.generators/not-empty","clojure.test.check.generators.such_that.cljs$core$IFn$_invoke$arity$2","clojure.test.check.generators/no-shrink","clojure.test.check.generators/shrink-2","cljs.core.comp.cljs$core$IFn$_invoke$arity$2","clojure.test.check.rose-tree/collapse","clojure.test.check.generators/boolean","i__4642__auto__","len__4641__auto__","args__4647__auto__","cljs.core/IndexedSeq","clojure.test.check.generators/tuple","argseq__4648__auto__","self__4629__auto__","seq11167","clojure.test.check.rose-tree/zip","cljs.core/vector","roses","clojure.test.check.generators/int","clojure.test.check.generators/nat","G__11169","Math/abs","p1__11168#","clojure.test.check.generators/pos-int","clojure.test.check.generators/neg-int","p1__11170#","clojure.test.check.generators/s-pos-int","cljs.core/inc","clojure.test.check.generators/s-neg-int","cljs.core/dec","G__11173","clojure.test.check.generators/vector","p1__11171#","cljs.core.repeat.cljs$core$IFn$_invoke$arity$2","num-elements-rose","clojure.test.check.rose-tree/shrink","num-elements","min-elements","max-elements","clojure.test.check.generators/list","p1__11174#","cljs.core/list","p__11175","vec__11176","clojure.test.check.generators/swap","cljs.core.assoc.cljs$core$IFn$_invoke$arity$variadic","i2","i1","clojure.test.check.generators/shuffle","p1__11179#","clojure.test.check.generators.vector.cljs$core$IFn$_invoke$arity$3","clojure.test.check.generators.tuple.cljs$core$IFn$_invoke$arity$variadic","index-gen","clojure.test.check.generators/hash-map","seq11181","cljs.core/even?","kvs","cljs.core.take_nth.cljs$core$IFn$_invoke$arity$2","cljs.core/rest","vs","p1__11180#","cljs.core/zipmap","ks","clojure.test.check.generators/transient-set-contains?","cljs.core._lookup.cljs$core$IFn$_invoke$arity$2","s","clojure.test.check.generators/coll-distinct-by*","cljs.core/transient","tries","rose-trees","cljs.core/persistent!","G__11183","G__11184","shuffle-fn","rest__11182#","empty-coll","vec__11185","rng1","key-fn","root","rng2","cljs.core.conj_BANG_.cljs$core$IFn$_invoke$arity$2","clojure.test.check.generators/distinct-by?","or__4047__auto__","cljs.core/empty?","cljs.core/distinct?","clojure.test.check.generators/the-shuffle-fn","cljs.core/empty","card","p__11188","vec__11189","vec__11192","idx","dec-card","swap-idx","cljs.core.range.cljs$core$IFn$_invoke$arity$1","p__11201","map__11202","clojure.test.check.generators/coll-distinct-by","ordered?","p1__11195#","allows-dupes?","cljs.core.every_pred.cljs$core$IFn$_invoke$arity$2","size-pred","p1__11196#","gen-size","hard-min-elements","p1__11197#","p1__11198#","p1__11199#","p1__11200#","G__11205","clojure.test.check.generators/vector-distinct","clojure.test.check.generators.vector_distinct.cljs$core$IFn$_invoke$arity$2","cljs.core/identity","opts","G__11207","clojure.test.check.generators/list-distinct","clojure.test.check.generators.list_distinct.cljs$core$IFn$_invoke$arity$2","G__11209","clojure.test.check.generators/vector-distinct-by","clojure.test.check.generators.vector_distinct_by.cljs$core$IFn$_invoke$arity$3","G__11211","clojure.test.check.generators/list-distinct-by","clojure.test.check.generators.list_distinct_by.cljs$core$IFn$_invoke$arity$3","G__11213","clojure.test.check.generators/set","clojure.test.check.generators.set.cljs$core$IFn$_invoke$arity$2","G__11215","clojure.test.check.generators/sorted-set","clojure.test.check.generators.sorted_set.cljs$core$IFn$_invoke$arity$2","cljs.core/sorted-set","G__11217","clojure.test.check.generators/map","clojure.test.check.generators.map.cljs$core$IFn$_invoke$arity$3","key-gen","val-gen","clojure.test.check.generators/gen-raw-long","clojure.test.check.random/rand-long","clojure.test.check.generators/MAX_INTEGER","cljs.core/*","clojure.test.check.generators/MIN_INTEGER","clojure.test.check.generators/abs","clojure.test.check.generators/long->large-integer","bit-count","G__11218","min","res","max","res'","G__11219","cljs.core/odd?","fexpr__11220","clojure.test.check.generators/large-integer**","x__4135__auto__","y__4136__auto__","x__4138__auto__","y__4139__auto__","vec__11221","max-bit-count","p__11227","map__11228","clojure.test.check.generators/large-integer*","p1__11224#","p1__11225#","p1__11226#","clojure.test.check.generators/large-integer","clojure.test.check.generators/POS_INFINITY","js/Number","clojure.test.check.generators/NEG_INFINITY","clojure.test.check.generators/MAX_POS_VALUE","clojure.test.check.generators/MIN_NEG_VALUE","clojure.test.check.generators/NAN","clojure.test.check.generators/uniform-integer","G__11230","p__11231","vec__11232","G__11235","clojure.test.check.generators/scalb","js/Math","exp","clojure.test.check.generators/fifty-two-bit-reverse","Math/pow","out","out-shifter","clojure.test.check.generators/backwards-shrinking-significand","clojure.test.check.generators/get-exponent","G__11236","Math/log","t","clojure.test.check.generators/double-exp-and-sign","lb","ub","qs8","lower-bound","upper-bound","gen-exp","lbexp","ubexp","p__11237","vec__11238","sign","pair","clojure.test.check.generators/block-bounds","vec__11241","G__11244","G__11245","high","low","clojure.test.check.generators/double-finite","p1__11246#","p1__11247#","p1__11248#","p__11249","vec__11250","vec__11253","significand","base","vec__11256","G__11259","G__11260","block-lb","block-ub","G__11261","p__11262","map__11263","clojure.test.check.generators/double*","G__11265","cljs.core.conj.cljs$core$IFn$_invoke$arity$variadic","and__4036__auto__","infinite?","cljs.core.conj.cljs$core$IFn$_invoke$arity$2","NaN?","frequency-arg","cljs.core/second","clojure.test.check.generators/double","clojure.test.check.generators/char","cljs.core/char","clojure.test.check.generators/char-ascii","clojure.test.check.generators/char-alphanumeric","clojure.test.check.generators/char-alpha-numeric","clojure.test.check.generators/char-alpha","clojure.test.check.generators/char-symbol-special","clojure.test.check.generators/char-keyword-rest","clojure.test.check.generators/char-keyword-first","clojure.test.check.generators/string","clojure.string/join","clojure.test.check.generators.vector.cljs$core$IFn$_invoke$arity$1","clojure.test.check.generators/string-ascii","clojure.test.check.generators/string-alphanumeric","clojure.test.check.generators/string-alpha-numeric","clojure.test.check.generators/digit?","goog.string/isNumeric","d","clojure.test.check.generators/+-or---digit?","cljs.core/boolean","c","clojure.test.check.generators/namespace-segment","p__11270","vec__11271","vec__11274","p__11266","vec__11267","clojure.string.join.cljs$core$IFn$_invoke$arity$1","cs","clojure.test.check.generators/namespace","clojure.string.join.cljs$core$IFn$_invoke$arity$2","clojure.test.check.generators/keyword-segment-rest","p__11277","vec__11278","clojure.test.check.generators/keyword-segment-first","p__11281","vec__11282","clojure.test.check.generators/keyword","p__11285","vec__11286","cljs.core.keyword.cljs$core$IFn$_invoke$arity$1","clojure.test.check.generators/keyword-ns","p__11289","vec__11290","cljs.core.keyword.cljs$core$IFn$_invoke$arity$2","ns","clojure.test.check.generators/char-symbol-first","clojure.test.check.generators/char-symbol-rest","clojure.test.check.generators/symbol","p__11297","vec__11298","vec__11301","p__11293","vec__11294","cljs.core.symbol.cljs$core$IFn$_invoke$arity$1","clojure.test.check.generators/symbol-ns","p__11308","vec__11309","vec__11312","p__11304","vec__11305","cljs.core.symbol.cljs$core$IFn$_invoke$arity$2","clojure.test.check.generators/ratio","p__11315","vec__11316","a","b","cljs.core/complement","cljs.core/zero?","clojure.test.check.generators/uuid","nibbles","cljs.core/uuid","hex","rhex","clojure.test.check.generators.vector.cljs$core$IFn$_invoke$arity$2","clojure.test.check.generators/simple-type","clojure.test.check.generators/simple-type-printable","clojure.test.check.generators/container-type","inner-type","clojure.test.check.generators.map.cljs$core$IFn$_invoke$arity$2","clojure.test.check.generators/recursive-helper","height","scalar-size","scalar-gen","children-size","G__11319","container-gen-fn","G__11320","G__11321","G__11322","G__11323","G__11324","clojure.test.check.generators/recursive-gen","G__11325","G__11326","clojure.test.check.generators/any","clojure.test.check.generators/any-printable"]}