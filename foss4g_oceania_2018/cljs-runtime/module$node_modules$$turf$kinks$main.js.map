{
"version":3,
"file":"module$node_modules$$turf$kinks$main.js",
"lineCount":5,
"mappings":"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",
"sources":["node_modules/@turf/kinks/main.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$$turf$kinks$main\"] = function(global,process,require,module,exports,shadow$shims) {\n'use strict';\n\nvar helpers = require('@turf/helpers');\n\n/**\n * Takes a {@link LineString|linestring}, {@link MultiLineString|multi-linestring}, {@link MultiPolygon|multi-polygon}, or {@link Polygon|polygon} and returns {@link Point|points} at all self-intersections.\n *\n * @name kinks\n * @param {Feature<LineString|MultiLineString|MultiPolygon|Polygon>} featureIn input feature\n * @returns {FeatureCollection<Point>} self-intersections\n * @example\n * var poly = turf.polygon([[\n *   [-12.034835, 8.901183],\n *   [-12.060413, 8.899826],\n *   [-12.03638, 8.873199],\n *   [-12.059383, 8.871418],\n *   [-12.034835, 8.901183]\n * ]]);\n *\n * var kinks = turf.kinks(poly);\n *\n * //addToMap\n * var addToMap = [poly, kinks]\n */\nfunction kinks(featureIn) {\n    var coordinates;\n    var feature;\n    var results = {\n        type: 'FeatureCollection',\n        features: []\n    };\n    if (featureIn.type === 'Feature') {\n        feature = featureIn.geometry;\n    } else {\n        feature = featureIn;\n    }\n    if (feature.type === 'LineString') {\n        coordinates = [feature.coordinates];\n    } else if (feature.type === 'MultiLineString') {\n        coordinates = feature.coordinates;\n    } else if (feature.type === 'MultiPolygon') {\n        coordinates = [].concat.apply([], feature.coordinates);\n    } else if (feature.type === 'Polygon') {\n        coordinates = feature.coordinates;\n    } else {\n        throw new Error('Input must be a LineString, MultiLineString, ' +\n            'Polygon, or MultiPolygon Feature or Geometry');\n    }\n    coordinates.forEach(function (line1) {\n        coordinates.forEach(function (line2) {\n            for (var i = 0; i < line1.length - 1; i++) {\n                // start iteration at i, intersections for k < i have already been checked in previous outer loop iterations\n                for (var k = i; k < line2.length - 1; k++) {\n                    if (line1 === line2) {\n                        // segments are adjacent and always share a vertex, not a kink\n                        if (Math.abs(i - k) === 1) {\n                            continue;\n                        }\n                        // first and last segment in a closed lineString or ring always share a vertex, not a kink\n                        if (\n                            // segments are first and last segment of lineString\n                            i === 0 &&\n                            k === line1.length - 2 &&\n                            // lineString is closed\n                            line1[i][0] === line1[line1.length - 1][0] &&\n                            line1[i][1] === line1[line1.length - 1][1]\n                        ) {\n                            continue;\n                        }\n                    }\n\n                    var intersection = lineIntersects(line1[i][0], line1[i][1], line1[i + 1][0], line1[i + 1][1],\n                        line2[k][0], line2[k][1], line2[k + 1][0], line2[k + 1][1]);\n                    if (intersection) {\n                        results.features.push(helpers.point([intersection[0], intersection[1]]));\n                    }\n                }\n            }\n        });\n    });\n    return results;\n}\n\n\n// modified from http://jsfiddle.net/justin_c_rounds/Gd2S2/light/\nfunction lineIntersects(line1StartX, line1StartY, line1EndX, line1EndY, line2StartX, line2StartY, line2EndX, line2EndY) {\n    // if the lines intersect, the result contains the x and y of the intersection (treating the lines as infinite) and booleans for whether line segment 1 or line segment 2 contain the point\n    var denominator, a, b, numerator1, numerator2,\n        result = {\n            x: null,\n            y: null,\n            onLine1: false,\n            onLine2: false\n        };\n    denominator = ((line2EndY - line2StartY) * (line1EndX - line1StartX)) - ((line2EndX - line2StartX) * (line1EndY - line1StartY));\n    if (denominator === 0) {\n        if (result.x !== null && result.y !== null) {\n            return result;\n        } else {\n            return false;\n        }\n    }\n    a = line1StartY - line2StartY;\n    b = line1StartX - line2StartX;\n    numerator1 = ((line2EndX - line2StartX) * a) - ((line2EndY - line2StartY) * b);\n    numerator2 = ((line1EndX - line1StartX) * a) - ((line1EndY - line1StartY) * b);\n    a = numerator1 / denominator;\n    b = numerator2 / denominator;\n\n    // if we cast these lines infinitely in both directions, they intersect here:\n    result.x = line1StartX + (a * (line1EndX - line1StartX));\n    result.y = line1StartY + (a * (line1EndY - line1StartY));\n\n    // if line1 is a segment and line2 is infinite, they intersect if:\n    if (a >= 0 && a <= 1) {\n        result.onLine1 = true;\n    }\n    // if line2 is a segment and line1 is infinite, they intersect if:\n    if (b >= 0 && b <= 1) {\n        result.onLine2 = true;\n    }\n    // if line1 and line2 are segments, they intersect if both of the above are true\n    if (result.onLine1 && result.onLine2) {\n        return [result.x, result.y];\n    } else {\n        return false;\n    }\n}\n\nmodule.exports = kinks;\nmodule.exports.default = kinks;\n\n};"],
"names":["shadow$provide","global","process","require","module","exports","shadow$shims","kinks","featureIn","results","type","features","feature","geometry","coordinates","concat","apply","Error","forEach","line1","line2","i","length","k","Math","abs","result","x","y","onLine1","onLine2","denominator","line2EndY","line2StartY","line1EndX","line1StartX","line2EndX","line2StartX","line1EndY","line1StartY","a","b","numerator2","intersection","push","helpers","point","default"]
}
