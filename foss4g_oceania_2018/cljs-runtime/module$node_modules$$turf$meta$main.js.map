{
"version":3,
"file":"module$node_modules$$turf$meta$main.js",
"lineCount":27,
"mappings":"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",
"sources":["node_modules/@turf/meta/main.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$$turf$meta$main\"] = function(global,process,require,module,exports,shadow$shims) {\n'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar helpers = require('@turf/helpers');\n\n/**\n * Callback for coordEach\n *\n * @callback coordEachCallback\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Iterate over coordinates in any GeoJSON object, similar to Array.forEach()\n *\n * @name coordEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentCoord, coordIndex, featureIndex, multiFeatureIndex)\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordEach(features, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction coordEach(geojson, callback, excludeWrapCoord) {\n    // Handles null Geometry -- Skips this GeoJSON\n    if (geojson === null) return;\n    var j, k, l, geometry, stopG, coords,\n        geometryMaybeCollection,\n        wrapShrink = 0,\n        coordIndex = 0,\n        isGeometryCollection,\n        type = geojson.type,\n        isFeatureCollection = type === 'FeatureCollection',\n        isFeature = type === 'Feature',\n        stop = isFeatureCollection ? geojson.features.length : 1;\n\n    // This logic may look a little weird. The reason why it is that way\n    // is because it's trying to be fast. GeoJSON supports multiple kinds\n    // of objects at its root: FeatureCollection, Features, Geometries.\n    // This function has the responsibility of handling all of them, and that\n    // means that some of the `for` loops you see below actually just don't apply\n    // to certain inputs. For instance, if you give this just a\n    // Point geometry, then both loops are short-circuited and all we do\n    // is gradually rename the input until it's called 'geometry'.\n    //\n    // This also aims to allocate as few resources as possible: just a\n    // few numbers and booleans, rather than any temporary arrays as would\n    // be required with the normalization approach.\n    for (var featureIndex = 0; featureIndex < stop; featureIndex++) {\n        geometryMaybeCollection = (isFeatureCollection ? geojson.features[featureIndex].geometry :\n            (isFeature ? geojson.geometry : geojson));\n        isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;\n        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n\n        for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {\n            var multiFeatureIndex = 0;\n            var geometryIndex = 0;\n            geometry = isGeometryCollection ?\n                geometryMaybeCollection.geometries[geomIndex] : geometryMaybeCollection;\n\n            // Handles null Geometry -- Skips this geometry\n            if (geometry === null) continue;\n            coords = geometry.coordinates;\n            var geomType = geometry.type;\n\n            wrapShrink = (excludeWrapCoord && (geomType === 'Polygon' || geomType === 'MultiPolygon')) ? 1 : 0;\n\n            switch (geomType) {\n            case null:\n                break;\n            case 'Point':\n                if (callback(coords, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                coordIndex++;\n                multiFeatureIndex++;\n                break;\n            case 'LineString':\n            case 'MultiPoint':\n                for (j = 0; j < coords.length; j++) {\n                    if (callback(coords[j], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                    coordIndex++;\n                    if (geomType === 'MultiPoint') multiFeatureIndex++;\n                }\n                if (geomType === 'LineString') multiFeatureIndex++;\n                break;\n            case 'Polygon':\n            case 'MultiLineString':\n                for (j = 0; j < coords.length; j++) {\n                    for (k = 0; k < coords[j].length - wrapShrink; k++) {\n                        if (callback(coords[j][k], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                        coordIndex++;\n                    }\n                    if (geomType === 'MultiLineString') multiFeatureIndex++;\n                    if (geomType === 'Polygon') geometryIndex++;\n                }\n                if (geomType === 'Polygon') multiFeatureIndex++;\n                break;\n            case 'MultiPolygon':\n                for (j = 0; j < coords.length; j++) {\n                    if (geomType === 'MultiPolygon') geometryIndex = 0;\n                    for (k = 0; k < coords[j].length; k++) {\n                        for (l = 0; l < coords[j][k].length - wrapShrink; l++) {\n                            if (callback(coords[j][k][l], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                            coordIndex++;\n                        }\n                        geometryIndex++;\n                    }\n                    multiFeatureIndex++;\n                }\n                break;\n            case 'GeometryCollection':\n                for (j = 0; j < geometry.geometries.length; j++)\n                    if (coordEach(geometry.geometries[j], callback, excludeWrapCoord) === false) return false;\n                break;\n            default:\n                throw new Error('Unknown Geometry Type');\n            }\n        }\n    }\n}\n\n/**\n * Callback for coordReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback coordReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Reduce coordinates in any GeoJSON object, similar to Array.reduce()\n *\n * @name coordReduce\n * @param {FeatureCollection|Geometry|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentCoord, coordIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordReduce(features, function (previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentCoord;\n * });\n */\nfunction coordReduce(geojson, callback, initialValue, excludeWrapCoord) {\n    var previousValue = initialValue;\n    coordEach(geojson, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n        if (coordIndex === 0 && initialValue === undefined) previousValue = currentCoord;\n        else previousValue = callback(previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex);\n    }, excludeWrapCoord);\n    return previousValue;\n}\n\n/**\n * Callback for propEach\n *\n * @callback propEachCallback\n * @param {Object} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over properties in any GeoJSON object, similar to Array.forEach()\n *\n * @name propEach\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentProperties, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propEach(features, function (currentProperties, featureIndex) {\n *   //=currentProperties\n *   //=featureIndex\n * });\n */\nfunction propEach(geojson, callback) {\n    var i;\n    switch (geojson.type) {\n    case 'FeatureCollection':\n        for (i = 0; i < geojson.features.length; i++) {\n            if (callback(geojson.features[i].properties, i) === false) break;\n        }\n        break;\n    case 'Feature':\n        callback(geojson.properties, 0);\n        break;\n    }\n}\n\n\n/**\n * Callback for propReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback propReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {*} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce properties in any GeoJSON object into a single value,\n * similar to how Array.reduce works. However, in this case we lazily run\n * the reduction, so an array of all properties is unnecessary.\n *\n * @name propReduce\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentProperties, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propReduce(features, function (previousValue, currentProperties, featureIndex) {\n *   //=previousValue\n *   //=currentProperties\n *   //=featureIndex\n *   return currentProperties\n * });\n */\nfunction propReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    propEach(geojson, function (currentProperties, featureIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentProperties;\n        else previousValue = callback(previousValue, currentProperties, featureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for featureEach\n *\n * @callback featureEachCallback\n * @param {Feature<any>} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name featureEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.featureEach(features, function (currentFeature, featureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n * });\n */\nfunction featureEach(geojson, callback) {\n    if (geojson.type === 'Feature') {\n        callback(geojson, 0);\n    } else if (geojson.type === 'FeatureCollection') {\n        for (var i = 0; i < geojson.features.length; i++) {\n            if (callback(geojson.features[i], i) === false) break;\n        }\n    }\n}\n\n/**\n * Callback for featureReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback featureReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name featureReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.featureReduce(features, function (previousValue, currentFeature, featureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   return currentFeature\n * });\n */\nfunction featureReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    featureEach(geojson, function (currentFeature, featureIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentFeature;\n        else previousValue = callback(previousValue, currentFeature, featureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Get all coordinates from any GeoJSON object.\n *\n * @name coordAll\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @returns {Array<Array<number>>} coordinate position array\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * var coords = turf.coordAll(features);\n * //= [[26, 37], [36, 53]]\n */\nfunction coordAll(geojson) {\n    var coords = [];\n    coordEach(geojson, function (coord) {\n        coords.push(coord);\n    });\n    return coords;\n}\n\n/**\n * Callback for geomEach\n *\n * @callback geomEachCallback\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Iterate over each geometry in any GeoJSON object, similar to Array.forEach()\n *\n * @name geomEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomEach(features, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n * });\n */\nfunction geomEach(geojson, callback) {\n    var i, j, g, geometry, stopG,\n        geometryMaybeCollection,\n        isGeometryCollection,\n        featureProperties,\n        featureBBox,\n        featureId,\n        featureIndex = 0,\n        isFeatureCollection = geojson.type === 'FeatureCollection',\n        isFeature = geojson.type === 'Feature',\n        stop = isFeatureCollection ? geojson.features.length : 1;\n\n    // This logic may look a little weird. The reason why it is that way\n    // is because it's trying to be fast. GeoJSON supports multiple kinds\n    // of objects at its root: FeatureCollection, Features, Geometries.\n    // This function has the responsibility of handling all of them, and that\n    // means that some of the `for` loops you see below actually just don't apply\n    // to certain inputs. For instance, if you give this just a\n    // Point geometry, then both loops are short-circuited and all we do\n    // is gradually rename the input until it's called 'geometry'.\n    //\n    // This also aims to allocate as few resources as possible: just a\n    // few numbers and booleans, rather than any temporary arrays as would\n    // be required with the normalization approach.\n    for (i = 0; i < stop; i++) {\n\n        geometryMaybeCollection = (isFeatureCollection ? geojson.features[i].geometry :\n            (isFeature ? geojson.geometry : geojson));\n        featureProperties = (isFeatureCollection ? geojson.features[i].properties :\n            (isFeature ? geojson.properties : {}));\n        featureBBox = (isFeatureCollection ? geojson.features[i].bbox :\n            (isFeature ? geojson.bbox : undefined));\n        featureId = (isFeatureCollection ? geojson.features[i].id :\n            (isFeature ? geojson.id : undefined));\n        isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;\n        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n\n        for (g = 0; g < stopG; g++) {\n            geometry = isGeometryCollection ?\n                geometryMaybeCollection.geometries[g] : geometryMaybeCollection;\n\n            // Handle null Geometry\n            if (geometry === null) {\n                if (callback(null, featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                continue;\n            }\n            switch (geometry.type) {\n            case 'Point':\n            case 'LineString':\n            case 'MultiPoint':\n            case 'Polygon':\n            case 'MultiLineString':\n            case 'MultiPolygon': {\n                if (callback(geometry, featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                break;\n            }\n            case 'GeometryCollection': {\n                for (j = 0; j < geometry.geometries.length; j++) {\n                    if (callback(geometry.geometries[j], featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                }\n                break;\n            }\n            default:\n                throw new Error('Unknown Geometry Type');\n            }\n        }\n        // Only increase `featureIndex` per each feature\n        featureIndex++;\n    }\n}\n\n/**\n * Callback for geomReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback geomReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Reduce geometry in any GeoJSON object, similar to Array.reduce().\n *\n * @name geomReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomReduce(features, function (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=previousValue\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n *   return currentGeometry\n * });\n */\nfunction geomReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    geomEach(geojson, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentGeometry;\n        else previousValue = callback(previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for flattenEach\n *\n * @callback flattenEachCallback\n * @param {Feature} currentFeature The current flattened feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Iterate over flattened features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name flattenEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex, multiFeatureIndex)\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenEach(features, function (currentFeature, featureIndex, multiFeatureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n * });\n */\nfunction flattenEach(geojson, callback) {\n    geomEach(geojson, function (geometry, featureIndex, properties, bbox, id) {\n        // Callback for single geometry\n        var type = (geometry === null) ? null : geometry.type;\n        switch (type) {\n        case null:\n        case 'Point':\n        case 'LineString':\n        case 'Polygon':\n            if (callback(helpers.feature(geometry, properties, {bbox: bbox, id: id}), featureIndex, 0) === false) return false;\n            return;\n        }\n\n        var geomType;\n\n        // Callback for multi-geometry\n        switch (type) {\n        case 'MultiPoint':\n            geomType = 'Point';\n            break;\n        case 'MultiLineString':\n            geomType = 'LineString';\n            break;\n        case 'MultiPolygon':\n            geomType = 'Polygon';\n            break;\n        }\n\n        for (var multiFeatureIndex = 0; multiFeatureIndex < geometry.coordinates.length; multiFeatureIndex++) {\n            var coordinate = geometry.coordinates[multiFeatureIndex];\n            var geom = {\n                type: geomType,\n                coordinates: coordinate\n            };\n            if (callback(helpers.feature(geom, properties), featureIndex, multiFeatureIndex) === false) return false;\n        }\n    });\n}\n\n/**\n * Callback for flattenReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback flattenReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Reduce flattened features in any GeoJSON object, similar to Array.reduce().\n *\n * @name flattenReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex, multiFeatureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenReduce(features, function (previousValue, currentFeature, featureIndex, multiFeatureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   return currentFeature\n * });\n */\nfunction flattenReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    flattenEach(geojson, function (currentFeature, featureIndex, multiFeatureIndex) {\n        if (featureIndex === 0 && multiFeatureIndex === 0 && initialValue === undefined) previousValue = currentFeature;\n        else previousValue = callback(previousValue, currentFeature, featureIndex, multiFeatureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for segmentEach\n *\n * @callback segmentEachCallback\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n * @returns {void}\n */\n\n/**\n * Iterate over 2-vertex line segment in any GeoJSON object, similar to Array.forEach()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex)\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentEach(polygon, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //=currentSegment\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   //=segmentIndex\n * });\n *\n * // Calculate the total number of segments\n * var total = 0;\n * turf.segmentEach(polygon, function () {\n *     total++;\n * });\n */\nfunction segmentEach(geojson, callback) {\n    flattenEach(geojson, function (feature$$1, featureIndex, multiFeatureIndex) {\n        var segmentIndex = 0;\n\n        // Exclude null Geometries\n        if (!feature$$1.geometry) return;\n        // (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n        var type = feature$$1.geometry.type;\n        if (type === 'Point' || type === 'MultiPoint') return;\n\n        // Generate 2-vertex line segments\n        var previousCoords;\n        if (coordEach(feature$$1, function (currentCoord, coordIndex, featureIndexCoord, mutliPartIndexCoord, geometryIndex) {\n            // Simulating a meta.coordReduce() since `reduce` operations cannot be stopped by returning `false`\n            if (previousCoords === undefined) {\n                previousCoords = currentCoord;\n                return;\n            }\n            var currentSegment = helpers.lineString([previousCoords, currentCoord], feature$$1.properties);\n            if (callback(currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) === false) return false;\n            segmentIndex++;\n            previousCoords = currentCoord;\n        }) === false) return false;\n    });\n}\n\n/**\n * Callback for segmentReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback segmentReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n */\n\n/**\n * Reduce 2-vertex line segment in any GeoJSON object, similar to Array.reduce()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (previousValue, currentSegment, currentIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentReduce(polygon, function (previousSegment, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //= previousSegment\n *   //= currentSegment\n *   //= featureIndex\n *   //= multiFeatureIndex\n *   //= geometryIndex\n *   //= segmentInex\n *   return currentSegment\n * });\n *\n * // Calculate the total number of segments\n * var initialValue = 0\n * var total = turf.segmentReduce(polygon, function (previousValue) {\n *     previousValue++;\n *     return previousValue;\n * }, initialValue);\n */\nfunction segmentReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    var started = false;\n    segmentEach(geojson, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n        if (started === false && initialValue === undefined) previousValue = currentSegment;\n        else previousValue = callback(previousValue, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex);\n        started = true;\n    });\n    return previousValue;\n}\n\n/**\n * Callback for lineEach\n *\n * @callback lineEachCallback\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Iterate over line or ring coordinates in LineString, Polygon, MultiLineString, MultiPolygon Features or Geometries,\n * similar to Array.forEach.\n *\n * @name lineEach\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @example\n * var multiLine = turf.multiLineString([\n *   [[26, 37], [35, 45]],\n *   [[36, 53], [38, 50], [41, 55]]\n * ]);\n *\n * turf.lineEach(multiLine, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction lineEach(geojson, callback) {\n    // validation\n    if (!geojson) throw new Error('geojson is required');\n\n    flattenEach(geojson, function (feature$$1, featureIndex, multiFeatureIndex) {\n        if (feature$$1.geometry === null) return;\n        var type = feature$$1.geometry.type;\n        var coords = feature$$1.geometry.coordinates;\n        switch (type) {\n        case 'LineString':\n            if (callback(feature$$1, featureIndex, multiFeatureIndex, 0, 0) === false) return false;\n            break;\n        case 'Polygon':\n            for (var geometryIndex = 0; geometryIndex < coords.length; geometryIndex++) {\n                if (callback(helpers.lineString(coords[geometryIndex], feature$$1.properties), featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n            }\n            break;\n        }\n    });\n}\n\n/**\n * Callback for lineReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback lineReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed.\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name lineReduce\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var multiPoly = turf.multiPolygon([\n *   turf.polygon([[[12,48],[2,41],[24,38],[12,48]], [[9,44],[13,41],[13,45],[9,44]]]),\n *   turf.polygon([[[5, 5], [0, 0], [2, 2], [4, 4], [5, 5]]])\n * ]);\n *\n * turf.lineReduce(multiPoly, function (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentLine\n * });\n */\nfunction lineReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    lineEach(geojson, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentLine;\n        else previousValue = callback(previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Finds a particular 2-vertex LineString Segment from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n * Point & MultiPoint will always return null.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.segmentIndex=0] Segment Index\n * @param {Object} [options.properties={}] Translate Properties to output LineString\n * @param {BBox} [options.bbox={}] Translate BBox to output LineString\n * @param {number|string} [options.id={}] Translate Id to output LineString\n * @returns {Feature<LineString>} 2-vertex GeoJSON Feature LineString\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findSegment(multiLine);\n * // => Feature<LineString<[[10, 10], [50, 30]]\u003e>\n *\n * // First Segment of 2nd Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: 1});\n * // => Feature<LineString<[[-10, -10], [-50, -30]]\u003e>\n *\n * // Last Segment of Last Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: -1, segmentIndex: -1});\n * // => Feature<LineString<[[-50, -30], [-30, -40]]\u003e>\n */\nfunction findSegment(geojson, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!helpers.isObject(options)) throw new Error('options is invalid');\n    var featureIndex = options.featureIndex || 0;\n    var multiFeatureIndex = options.multiFeatureIndex || 0;\n    var geometryIndex = options.geometryIndex || 0;\n    var segmentIndex = options.segmentIndex || 0;\n\n    // Find FeatureIndex\n    var properties = options.properties;\n    var geometry;\n\n    switch (geojson.type) {\n    case 'FeatureCollection':\n        if (featureIndex < 0) featureIndex = geojson.features.length + featureIndex;\n        properties = properties || geojson.features[featureIndex].properties;\n        geometry = geojson.features[featureIndex].geometry;\n        break;\n    case 'Feature':\n        properties = properties || geojson.properties;\n        geometry = geojson.geometry;\n        break;\n    case 'Point':\n    case 'MultiPoint':\n        return null;\n    case 'LineString':\n    case 'Polygon':\n    case 'MultiLineString':\n    case 'MultiPolygon':\n        geometry = geojson;\n        break;\n    default:\n        throw new Error('geojson is invalid');\n    }\n\n    // Find SegmentIndex\n    if (geometry === null) return null;\n    var coords = geometry.coordinates;\n    switch (geometry.type) {\n    case 'Point':\n    case 'MultiPoint':\n        return null;\n    case 'LineString':\n        if (segmentIndex < 0) segmentIndex = coords.length + segmentIndex - 1;\n        return helpers.lineString([coords[segmentIndex], coords[segmentIndex + 1]], properties, options);\n    case 'Polygon':\n        if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n        if (segmentIndex < 0) segmentIndex = coords[geometryIndex].length + segmentIndex - 1;\n        return helpers.lineString([coords[geometryIndex][segmentIndex], coords[geometryIndex][segmentIndex + 1]], properties, options);\n    case 'MultiLineString':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (segmentIndex < 0) segmentIndex = coords[multiFeatureIndex].length + segmentIndex - 1;\n        return helpers.lineString([coords[multiFeatureIndex][segmentIndex], coords[multiFeatureIndex][segmentIndex + 1]], properties, options);\n    case 'MultiPolygon':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (geometryIndex < 0) geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n        if (segmentIndex < 0) segmentIndex = coords[multiFeatureIndex][geometryIndex].length - segmentIndex - 1;\n        return helpers.lineString([coords[multiFeatureIndex][geometryIndex][segmentIndex], coords[multiFeatureIndex][geometryIndex][segmentIndex + 1]], properties, options);\n    }\n    throw new Error('geojson is invalid');\n}\n\n/**\n * Finds a particular Point from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.coordIndex=0] Coord Index\n * @param {Object} [options.properties={}] Translate Properties to output Point\n * @param {BBox} [options.bbox={}] Translate BBox to output Point\n * @param {number|string} [options.id={}] Translate Id to output Point\n * @returns {Feature<Point>} 2-vertex GeoJSON Feature Point\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findPoint(multiLine);\n * // => Feature<Point<[10, 10]>>\n *\n * // First Segment of the 2nd Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: 1});\n * // => Feature<Point<[-10, -10]>>\n *\n * // Last Segment of last Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: -1, coordIndex: -1});\n * // => Feature<Point<[-30, -40]>>\n */\nfunction findPoint(geojson, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!helpers.isObject(options)) throw new Error('options is invalid');\n    var featureIndex = options.featureIndex || 0;\n    var multiFeatureIndex = options.multiFeatureIndex || 0;\n    var geometryIndex = options.geometryIndex || 0;\n    var coordIndex = options.coordIndex || 0;\n\n    // Find FeatureIndex\n    var properties = options.properties;\n    var geometry;\n\n    switch (geojson.type) {\n    case 'FeatureCollection':\n        if (featureIndex < 0) featureIndex = geojson.features.length + featureIndex;\n        properties = properties || geojson.features[featureIndex].properties;\n        geometry = geojson.features[featureIndex].geometry;\n        break;\n    case 'Feature':\n        properties = properties || geojson.properties;\n        geometry = geojson.geometry;\n        break;\n    case 'Point':\n    case 'MultiPoint':\n        return null;\n    case 'LineString':\n    case 'Polygon':\n    case 'MultiLineString':\n    case 'MultiPolygon':\n        geometry = geojson;\n        break;\n    default:\n        throw new Error('geojson is invalid');\n    }\n\n    // Find Coord Index\n    if (geometry === null) return null;\n    var coords = geometry.coordinates;\n    switch (geometry.type) {\n    case 'Point':\n        return helpers.point(coords, properties, options);\n    case 'MultiPoint':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        return helpers.point(coords[multiFeatureIndex], properties, options);\n    case 'LineString':\n        if (coordIndex < 0) coordIndex = coords.length + coordIndex;\n        return helpers.point(coords[coordIndex], properties, options);\n    case 'Polygon':\n        if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n        if (coordIndex < 0) coordIndex = coords[geometryIndex].length + coordIndex;\n        return helpers.point(coords[geometryIndex][coordIndex], properties, options);\n    case 'MultiLineString':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (coordIndex < 0) coordIndex = coords[multiFeatureIndex].length + coordIndex;\n        return helpers.point(coords[multiFeatureIndex][coordIndex], properties, options);\n    case 'MultiPolygon':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (geometryIndex < 0) geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n        if (coordIndex < 0) coordIndex = coords[multiFeatureIndex][geometryIndex].length - coordIndex;\n        return helpers.point(coords[multiFeatureIndex][geometryIndex][coordIndex], properties, options);\n    }\n    throw new Error('geojson is invalid');\n}\n\nexports.coordEach = coordEach;\nexports.coordReduce = coordReduce;\nexports.propEach = propEach;\nexports.propReduce = propReduce;\nexports.featureEach = featureEach;\nexports.featureReduce = featureReduce;\nexports.coordAll = coordAll;\nexports.geomEach = geomEach;\nexports.geomReduce = geomReduce;\nexports.flattenEach = flattenEach;\nexports.flattenReduce = flattenReduce;\nexports.segmentEach = segmentEach;\nexports.segmentReduce = segmentReduce;\nexports.lineEach = lineEach;\nexports.lineReduce = lineReduce;\nexports.findSegment = findSegment;\nexports.findPoint = findPoint;\n\n};"],
"names":["shadow$provide","global","process","require","module","exports","shadow$shims","coordEach","geojson","callback","excludeWrapCoord","l","geometryMaybeCollection","coordIndex","isGeometryCollection","type","isFeatureCollection","isFeature","stop","features","length","featureIndex","stopG","geometry","geometries","geomIndex","multiFeatureIndex","geometryIndex","coords","coordinates","geomType","wrapShrink","j","k","Error","propEach","i","properties","featureEach","geomEach","g","featureProperties","featureBBox","bbox","undefined","featureId","id","flattenEach","helpers","feature","geom","coordinate","segmentEach","feature$$1","segmentIndex","previousCoords","currentCoord","featureIndexCoord","mutliPartIndexCoord","currentSegment","lineString","lineEach","Object","defineProperty","value","coordReduce","initialValue","previousValue","propReduce","currentProperties","featureReduce","currentFeature","coordAll","coord","push","geomReduce","currentGeometry","flattenReduce","segmentReduce","started","lineReduce","currentLine","findSegment","options","isObject","findPoint","point"]
}
