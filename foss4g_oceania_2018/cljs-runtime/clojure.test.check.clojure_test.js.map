{"version":3,"sources":["clojure/test/check/clojure_test.cljc"],"sourcesContent":[";   Copyright (c) Rich Hickey, Reid Draper, and contributors.\n;   All rights reserved.\n;   The use and distribution terms for this software are covered by the\n;   Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)\n;   which can be found in the file epl-v10.html at the root of this distribution.\n;   By using this software in any fashion, you are agreeing to be bound by\n;   the terms of this license.\n;   You must not remove this notice, or any other, from this software.\n\n(ns clojure.test.check.clojure-test\n  (:require #?(:clj  [clojure.test :as ct]\n               :cljs [cljs.test :as ct :include-macros true])\n            [clojure.test.check.impl :refer [get-current-time-millis\n                                             exception-like?]]))\n\n(defn assert-check\n  [{:keys [result] :as m}]\n  (prn m)\n  (if (exception-like? result)\n    (throw result)\n    (ct/is result)))\n\n(def ^:dynamic *default-test-count* 100)\n\n(defn process-options\n  {:no-doc true}\n  [options]\n  (cond (nil? options) {:num-tests *default-test-count*}\n        (number? options) {:num-tests options}\n        (map? options) (if (:num-tests options)\n                         options\n                         (assoc options :num-tests *default-test-count*))\n        :else (throw (ex-info (str \"Invalid defspec options: \" (pr-str options))\n                              {:bad-options options}))))\n\n#?(:clj\n(defmacro defspec\n  \"Defines a new clojure.test test var that uses `quick-check` to verify\n  [property] with the given [args] (should be a sequence of generators),\n  [default-times] times by default.  You can call the function defined as [name]\n  with no arguments to trigger this test directly (i.e., without starting a\n  wider clojure.test run), with a single argument that will override\n  [default-times], or with a map containing any of the keys\n  [:seed :max-size :num-tests].\"\n  {:arglists '([name property] [name num-tests? property] [name options? property])}\n  ([name property] `(defspec ~name nil ~property))\n  ([name options property]\n     ;; consider my shame for introducing a cyclical dependency like this...\n     ;; Don't think we'll know what the solution is until clojure.test.check\n     ;; integration with another test framework is attempted.\n     (require 'clojure.test.check)\n     `(defn ~(vary-meta name assoc\n                        ::defspec true\n                        :test `#(clojure.test.check.clojure-test/assert-check\n                                   (assoc (~name) :test-var (str '~name))))\n        ([] (let [options# (process-options ~options)]\n              (apply ~name (:num-tests options#) (apply concat options#))))\n        ([~'times & {:keys [~'seed ~'max-size] :as ~'quick-check-opts}]\n         (apply\n          clojure.test.check/quick-check\n          ~'times\n          (vary-meta ~property assoc :name (str '~property))\n          (apply concat ~'quick-check-opts)))))))\n\n(def ^:dynamic *report-trials*\n  \"Controls whether property trials should be reported via clojure.test/report.\n  Valid values include:\n\n  * false - no reporting of trials (default)\n  * a function - will be passed a clojure.test/report-style map containing\n  :clojure.test.check/property and :clojure.test.check/trial slots\n  * true - provides quickcheck-style trial reporting (dots) via\n  `trial-report-dots`\n\n  (Note that all reporting requires running `quick-check` within the scope of a\n  clojure.test run (via `test-ns`, `test-all-vars`, etc.)\n\n  Reporting functions offered by clojure.test.check include `trial-report-dots` and\n  `trial-report-periodic` (which prints more verbose trial progress information\n  every `*trial-report-period*` milliseconds.\"\n  false)\n\n(def ^:dynamic *report-shrinking*\n  \"If true, a verbose report of the property being tested, the\n  failing return value, and the arguments provoking that failure is emitted\n  prior to the start of the shrinking search.\"\n  false)\n\n(def ^:dynamic *trial-report-period*\n  \"Milliseconds between reports emitted by `trial-report-periodic`.\"\n  10000)\n\n(def ^:private last-trial-report (atom 0))\n\n(let [begin-test-var-method (get-method ct/report #?(:clj  :begin-test-var\n                                                     :cljs [::ct/default :begin-test-var]))]\n  (defmethod ct/report #?(:clj  :begin-test-var\n                          :cljs [::ct/default :begin-test]) [m]\n    (reset! last-trial-report (get-current-time-millis))\n    (when begin-test-var-method (begin-test-var-method m))))\n\n(defn- get-property-name\n  [{property-fun ::property :as report-map}]\n  (or (-> property-fun meta :name) (ct/testing-vars-str report-map)))\n\n(defn with-test-out* [f]\n  #?(:clj  (ct/with-test-out (f))\n     :cljs (f)))\n\n(defn trial-report-periodic\n  \"Intended to be bound as the value of `*report-trials*`; will emit a verbose\n  status every `*trial-report-period*` milliseconds, like this one:\n\n  Passing trial 3286 / 5000 for (your-test-var-name-here) (:)\"\n  [m]\n  (let [t (get-current-time-millis)]\n    (when (> (- t *trial-report-period*) @last-trial-report)\n      (with-test-out*\n        (fn []\n          (println \"Passing trial\"\n                   (-> m ::trial first) \"/\" (-> m ::trial second)\n                   \"for\" (get-property-name m))))\n      (reset! last-trial-report t))))\n\n(defn trial-report-dots\n  \"Intended to be bound as the value of `*report-trials*`; will emit a single\n  dot every 1000 trials reported.\"\n  [{[so-far total] ::trial}]\n  (when (pos? so-far)\n    (when (zero? (mod so-far 1000))\n      (print \".\")\n      (flush))\n    (when (== so-far total) (println))))\n\n(defmethod ct/report #?(:clj ::trial :cljs [::ct/default ::trial]) [m]\n  (when-let [trial-report-fn (and *report-trials*\n                                  (if (true? *report-trials*)\n                                    trial-report-dots\n                                    *report-trials*))]\n    (trial-report-fn m)))\n\n(defmethod ct/report #?(:clj ::shrinking :cljs [::ct/default ::shrinking]) [m]\n  (when *report-shrinking*\n    (with-test-out*\n      (fn []\n        (println \"Shrinking\" (get-property-name m)\n                 \"starting with parameters\" (pr-str (::params m)))))))\n\n(defn report-trial\n  [property-fun so-far num-tests]\n  (ct/report {:type ::trial\n              ::property property-fun\n              ::trial [so-far num-tests]}))\n\n(defn report-failure\n  [property-fun result trial-number failing-params]\n  ;; TODO this is wrong, makes it impossible to clojure.test quickchecks that\n  ;; should fail...\n  #_(ct/report (if (exception-like? result)\n                 {:type :error\n                  :message (.getMessage result)\n                  :actual result}\n                 {:type :fail\n                  :expected true\n                  :actual result}))\n  (ct/report {:type ::shrinking\n              ::property property-fun\n              ::params (vec failing-params)}))\n"],"mappings":"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","names":["p__11064","map__11065","cljs.core/PROTOCOL_SENTINEL","cljs.core.apply.cljs$core$IFn$_invoke$arity$2","cljs.core/hash-map","cljs.core.get.cljs$core$IFn$_invoke$arity$2","clojure.test.check.clojure-test/assert-check","cljs.core.prn.cljs$core$IFn$_invoke$arity$variadic","m","clojure.test.check.impl/exception-like?","result","value__8933__auto__","cljs.test/do-report","e11067","t__8961__auto__","clojure.test.check.clojure-test/*default-test-count*","clojure.test.check.clojure-test/process-options","options","cljs.core/map?","cljs.core.assoc.cljs$core$IFn$_invoke$arity$3","cljs.core.ex_info.cljs$core$IFn$_invoke$arity$2","cljs.core.pr_str.cljs$core$IFn$_invoke$arity$variadic","clojure.test.check.clojure-test/*report-trials*","clojure.test.check.clojure-test/*report-shrinking*","clojure.test.check.clojure-test/*trial-report-period*","clojure.test.check.clojure-test/last-trial-report","cljs.core.atom.cljs$core$IFn$_invoke$arity$1","cljs.core/get-method","cljs.test/report","cljs.core/reset!","clojure.test.check.impl/get-current-time-millis","begin-test-var-method","p__11087","map__11088","clojure.test.check.clojure-test/get-property-name","or__4047__auto__","property-fun","cljs.core/meta","cljs.test/testing-vars-str","report-map","clojure.test.check.clojure-test/with-test-out*","f","clojure.test.check.clojure-test/trial-report-periodic","cljs.core/deref","t","cljs.core.println.cljs$core$IFn$_invoke$arity$variadic","cljs.core/first","cljs.core/second","p__11096","map__11097","cljs.core.nth.cljs$core$IFn$_invoke$arity$3","vec__11098","clojure.test.check.clojure-test/trial-report-dots","so-far","cljs.core/mod","cljs.core.print.cljs$core$IFn$_invoke$arity$variadic","cljs.core/flush","total","cljs.core/println","temp__5457__auto__","and__4036__auto__","trial-report-fn","clojure.test.check.clojure-test/report-trial","G__11111","num-tests","clojure.test.check.clojure-test/report-failure","G__11112","cljs.core/vec","failing-params"]}