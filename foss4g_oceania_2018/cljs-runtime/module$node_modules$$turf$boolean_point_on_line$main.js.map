{
"version":3,
"file":"module$node_modules$$turf$boolean_point_on_line$main.js",
"lineCount":4,
"mappings":"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",
"sources":["node_modules/@turf/boolean-point-on-line/main.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$$turf$boolean_point_on_line$main\"] = function(global,process,require,module,exports,shadow$shims) {\n'use strict';\n\nvar invariant = require('@turf/invariant');\nvar helpers = require('@turf/helpers');\n\n/**\n * Returns true if a point is on a line. Accepts a optional parameter to ignore the start and end vertices of the linestring.\n *\n * @name booleanPointOnLine\n * @param {Coord} pt GeoJSON Point\n * @param {Feature<LineString>} line GeoJSON LineString\n * @param {Object} [options={}] Optional parameters\n * @param {boolean} [options.ignoreEndVertices=false] whether to ignore the start and end vertices.\n * @returns {boolean} true/false\n * @example\n * var pt = turf.point([0, 0]);\n * var line = turf.lineString([[-1, -1],[1, 1],[1.5, 2.2]]);\n * var isPointOnLine = turf.booleanPointOnLine(pt, line);\n * //=true\n */\nfunction booleanPointOnLine(pt, line, options) {\n    // Optional parameters\n    options = options || {};\n    var ignoreEndVertices = options.ignoreEndVertices;\n    if (!helpers.isObject(options)) throw new Error('invalid options');\n\n    // Validate input\n    if (!pt) throw new Error('pt is required');\n    if (!line) throw new Error('line is required');\n\n    // Normalize inputs\n    var ptCoords = invariant.getCoord(pt);\n    var lineCoords = invariant.getCoords(line);\n\n    // Main\n    for (var i = 0; i < lineCoords.length - 1; i++) {\n        var ignoreBoundary = false;\n        if (ignoreEndVertices) {\n            if (i === 0) ignoreBoundary = 'start';\n            if (i === lineCoords.length - 2) ignoreBoundary = 'end';\n            if (i === 0 && i + 1 === lineCoords.length - 1) ignoreBoundary = 'both';\n        }\n        if (isPointOnLineSegment(lineCoords[i], lineCoords[i + 1], ptCoords, ignoreBoundary)) return true;\n    }\n    return false;\n}\n\n// See http://stackoverflow.com/a/4833823/1979085\n/**\n * @private\n * @param {Position} lineSegmentStart coord pair of start of line\n * @param {Position} lineSegmentEnd coord pair of end of line\n * @param {Position} pt coord pair of point to check\n * @param {boolean|string} excludeBoundary whether the point is allowed to fall on the line ends. If true which end to ignore.\n * @returns {boolean} true/false\n */\nfunction isPointOnLineSegment(lineSegmentStart, lineSegmentEnd, pt, excludeBoundary) {\n    var x = pt[0];\n    var y = pt[1];\n    var x1 = lineSegmentStart[0];\n    var y1 = lineSegmentStart[1];\n    var x2 = lineSegmentEnd[0];\n    var y2 = lineSegmentEnd[1];\n    var dxc = pt[0] - x1;\n    var dyc = pt[1] - y1;\n    var dxl = x2 - x1;\n    var dyl = y2 - y1;\n    var cross = dxc * dyl - dyc * dxl;\n    if (cross !== 0) {\n        return false;\n    }\n    if (!excludeBoundary) {\n        if (Math.abs(dxl) >= Math.abs(dyl)) {\n            return dxl > 0 ? x1 <= x && x <= x2 : x2 <= x && x <= x1;\n        }\n        return dyl > 0 ? y1 <= y && y <= y2 : y2 <= y && y <= y1;\n    } else if (excludeBoundary === 'start') {\n        if (Math.abs(dxl) >= Math.abs(dyl)) {\n            return dxl > 0 ? x1 < x && x <= x2 : x2 <= x && x < x1;\n        }\n        return dyl > 0 ? y1 < y && y <= y2 : y2 <= y && y < y1;\n    } else if (excludeBoundary === 'end') {\n        if (Math.abs(dxl) >= Math.abs(dyl)) {\n            return dxl > 0 ? x1 <= x && x < x2 : x2 < x && x <= x1;\n        }\n        return dyl > 0 ? y1 <= y && y < y2 : y2 < y && y <= y1;\n    } else if (excludeBoundary === 'both') {\n        if (Math.abs(dxl) >= Math.abs(dyl)) {\n            return dxl > 0 ? x1 < x && x < x2 : x2 < x && x < x1;\n        }\n        return dyl > 0 ? y1 < y && y < y2 : y2 < y && y < y1;\n    }\n}\n\nmodule.exports = booleanPointOnLine;\nmodule.exports.default = booleanPointOnLine;\n\n};"],
"names":["shadow$provide","global","process","require","module","exports","shadow$shims","booleanPointOnLine","pt","line","options","ignoreEndVertices","helpers","isObject","Error","ptCoords","invariant","getCoord","lineCoords","getCoords","i","length","ignoreBoundary","x","y","x1","lineSegmentStart","y1","x2","lineSegmentEnd","y2","dxl","dyl","Math","abs","default"]
}
